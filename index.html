<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monad Dog</title>

<!-- Supabase Client -->
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Farcaster Manifest Link -->
  <link rel="manifest" href="/farcaster.json">
  <link rel="icon" type="image/png" href="https://monad-snowy.vercel.app/.well-known/icon.png">
  
  <!-- Farcaster Meta with Dynamic Content -->
  <meta name="fc:frame" content='{
    "version": "next",
    "imageUrl": "https://monad-snowy.vercel.app/.well-known/share.png",
    "button": {
      "title": "üêï Play Monad Dog",
      "action": {
        "type": "launch_frame",
        "url": "https://monad-snowy.vercel.app",
        "name": "Monad Dog",
        "splashImageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
        "splashBackgroundColor": "#1e003e"
      }
    }
  }'

  <!-- Open Graph for better sharing -->
  <meta property="og:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta property="og:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta property="og:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />
  <meta property="og:url" content="https://monad-snowy.vercel.app" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta name="twitter:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta name="twitter:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Farcaster Mini App SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/frame-sdk';
    
    // Mini App ready when loaded
    window.addEventListener('load', async () => {
      try {
        await sdk.actions.ready();
        console.log('Farcaster Mini App ready!');
        
        // Make SDK available globally
        window.farcasterSDK = sdk;
      } catch (error) {
        console.log('Not running in Farcaster client:', error);
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .social-link {
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      transition: all 0.3s ease;
      margin-top: 15px;
    }
    
    .social-link:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    
    .social-link svg {
      width: 20px;
      height: 20px;
      fill: white;
    }
    
    .xp {
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 20px;
    }
    
    .wallet-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background: #5855e8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tabs {
      display: flex;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
      flex-wrap: wrap;
    }
    
    .tab {
      flex: 1;
      min-width: 80px;
      padding: 12px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab.active {
      background: #6366f1;
    }
    
    .content {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      min-height: 200px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .dog-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 20px auto;
      display: block;
    }
    
    .coin {
      font-size: 60px;
      margin: 20px;
      transition: transform 0.5s;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }
    
    .status.visible {
      display: block;
    }
    
    .status.success {
      background: rgba(0,255,0,0.2);
      color: #00ff00;
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
      color: #ff6b6b;
    }
    
    .status.pending {
      background: rgba(255,255,0,0.2);
      color: #ffeb3b;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    .loading-subtitle {
      font-size: 14px;
      opacity: 0.7;
      text-align: center;
      max-width: 280px;
      line-height: 1.4;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Skeleton Loading States */
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 16px;
      border-radius: 4px;
      margin: 8px 0;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-button {
      height: 44px;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Hide content initially to prevent layout shift */
    .app-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .app-content.loaded {
      opacity: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    th {
      background: rgba(255,255,255,0.1);
    }
    
    .address {
      font-family: monospace;
      font-size: 12px;
    }

    .badge {
      background: #ff6b9d;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .rank-number {
      font-weight: 600;
      color: #6366f1;
      width: 40px;
    }

    .address-cell {
      font-family: monospace;
      font-size: 12px;
    }

    .share-button {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin: 10px 5px;
      width: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
    }

    .share-section {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .achievement-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    .achievement-content {
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 350px;
      border: 2px solid #6366f1;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 0.6s ease;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      padding: 5px;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .close-modal:hover {
      opacity: 1;
    }

    /* Token Claim Styles */
    .token-stats {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      padding: 8px 16px;
      border-radius: 20px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
      font-size: 14px;
      font-weight: 600;
    }

    .claim-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .claim-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .claim-info-item {
      text-align: center;
    }

    .claim-info-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .claim-info-value {
      font-size: 20px;
      font-weight: 600;
      color: #f59e0b;
    }

    .claim-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 14px 28px;
      border-radius: 12px;
      width: 100%;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .claim-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .claim-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
    }

    .token-balance {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 10px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: 8px;
      font-size: 14px;
    }

    .conversion-rate {
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }

    .claim-history {
      margin-top: 20px;
      font-size: 12px;
      opacity: 0.7;
    }

    .claim-history-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* Slots Machine Styles */
    .slots-machine {
      background: rgba(255,255,255,0.1);
      padding: 25px;
      border-radius: 16px;
      margin: 20px 0;
      border: 2px solid rgba(255,255,255,0.2);
    }

    .slots-display {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 25px 0;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid #6366f1;
    }

    .slot-reel {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }

    .slot-reel.spinning {
      animation: spin-reel 0.1s linear infinite;
    }

    .slot-reel.winning {
      background: rgba(16, 185, 129, 0.3);
      border-color: #10b981;
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
    }

    @keyframes spin-reel {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }

    .slots-info {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .slots-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 12px;
      width: 100%;
      margin: 15px 0;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .slots-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .slots-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
      transform: none;
    }

    .slots-legend {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .symbol-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .symbol-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
    }

    .symbol {
      font-size: 24px;
    }

    .symbol-name {
      font-size: 14px;
      opacity: 0.8;
    }

    .slots-jackpot {
      background: linear-gradient(135deg, #ffd700, #ffed4a);
      color: #1a1a1a;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      text-align: center;
      font-weight: 600;
      animation: jackpot-glow 2s ease-in-out infinite;
    }

    @keyframes jackpot-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
    }

    /* Dog Fortune Wheel Styles */
    .wheel-container {
      position: relative;
      width: 350px;
      height: 350px;
      margin: 20px auto;
    }

    .wheel-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }

    .dog-logo {
      font-size: 40px;
      animation: wag 2s ease-in-out infinite;
    }

    @keyframes wag {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }

    .wheel-pointer {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 30px;
      color: #ff6b6b;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      z-index: 11;
    }

    #wheelCanvas {
      animation: subtle-float 3s ease-in-out infinite;
    }

    @keyframes subtle-float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }

    .wheel-button {
      background: linear-gradient(135deg, #ff6b6b, #ff8e53);
      font-size: 20px;
      padding: 18px 36px;
      animation: pulse-glow 2s ease-in-out infinite;
      width: 100%;
      margin: 15px 0;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.3); }
      50% { box-shadow: 0 0 30px rgba(255, 107, 107, 0.6); }
    }

    .wheel-info {
      display: flex;
      justify-content: center;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .spin-cost {
      font-size: 16px;
      color: #f59e0b;
      font-weight: 600;
    }

    .recent-wins {
      margin-top: 30px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .win-item {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      margin: 5px 0;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      animation: slideIn 0.5s ease;
      font-size: 14px;
    }

    @keyframes slideIn {
      from { 
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .prize-legend {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .prize-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .prize-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      font-size: 14px;
    }

    .prize-emoji {
      font-size: 24px;
    }

    .prize-xp {
      font-weight: 600;
      color: #f59e0b;
    }
  </style>
</head>
<body>
  <div class="container app-content">
    <div class="header">
      <div class="title">üêï Monad Dog</div>
      <div class="xp">‚ú® Available XP: <span id="xp">0</span></div>
      
      <a href="https://x.com/monaddogg" target="_blank" class="social-link" title="Follow us on Twitter">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
      </a>
    </div>

    <div class="wallet-section">
      <div id="connect-area">
        <button id="connect-btn">üü£ Connect Wallet</button>
      </div>
      <div id="connected-area" style="display: none;">
        <div>üü£ Connected</div>
        <div id="address" class="address"></div>
        <button id="disconnect-btn">Disconnect</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="showTab('pet')">üêï Pet</button>
      <button class="tab" onclick="showTab('greet')">üëã Greet</button>
      <button class="tab" onclick="showTab('flip')">ü™ô Flip</button>
      <button class="tab" onclick="showTab('slots')">üé∞ Slots</button>
      <button class="tab" onclick="showTab('wheel')">üéØ Wheel</button>
      <button class="tab" onclick="showTab('claim')">üí∞ Claim</button>
    </div>

    <div class="content">
      <!-- Pet Tab -->
      <div id="pet" class="tab-content active">
        <h3>Pet the Dog</h3>
        <img id="dog-img" class="dog-image" src="https://placedog.net/400/300?id=7" alt="Dog">
        <button onclick="petDog()">üëã Pet Dog (+10 XP)</button>
        <div id="pet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareFlipAchievement()">
            ü™ô Share Lucky Moment
          </button>
        </div>
      </div>

      <!-- Slots Tab -->
      <div id="slots" class="tab-content">
        <h3>üé∞ Dog Slots</h3>
        <p style="margin-bottom: 20px;">Match 4 same dogs or bones to win 5000 XP!</p>
        
        <div class="slots-machine">
          <div class="slots-display">
            <div class="slot-reel" id="reel1">üêï</div>
            <div class="slot-reel" id="reel2">ü¶Æ</div>
            <div class="slot-reel" id="reel3">üê∂</div>
            <div class="slot-reel" id="reel4">ü¶¥</div>
          </div>
          
          <div class="slots-info">
            <div class="cost-info">
              <span style="color: #f59e0b;">üí∞ Pay: 0.1 MONAD = 2 Credits</span>
            </div>
            <div class="prize-info">
              <span style="color: #10b981;">üèÜ 4 Match = 5000 XP</span>
            </div>
          </div>
          
          <button class="slots-button" id="slotsButton" onclick="playSlots()">
            üîí Connect Wallet
          </button>
          
          <div id="slots-status" class="status"></div>
        </div>
        
        <div class="slots-legend">
          <h4 style="margin: 20px 0 10px 0;">How It Works:</h4>
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: left;">
            <p style="margin-bottom: 8px;">üí∞ <strong>Pay 0.1 MONAD</strong> ‚Üí Get 2 game credits</p>
            <p style="margin-bottom: 8px;">üéÆ <strong>Each game</strong> ‚Üí Uses 1 credit</p>
            <p style="margin-bottom: 8px;">‚úÖ <strong>Credits awarded</strong> ‚Üí Only after TX confirms</p>
            <p>üé∞ <strong>Play anytime</strong> ‚Üí Use your available credits</p>
          </div>
          
          <h4 style="margin: 20px 0 10px 0;">Symbols & Prizes:</h4>
          <div class="symbol-grid">
            <div class="symbol-item">
              <span class="symbol">üêï</span>
              <span class="symbol-name">Shiba</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">ü¶Æ</span>
              <span class="symbol-name">Guide Dog</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">üê∂</span>
              <span class="symbol-name">Puppy</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">ü¶¥</span>
              <span class="symbol-name">Bone</span>
            </div>
          </div>
          
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 15px; text-align: left;">
            <p style="margin-bottom: 5px;">üéâ <strong>4 Same:</strong> 5000 XP (JACKPOT!)</p>
            <p style="margin-bottom: 5px;">üèÜ <strong>3 Same:</strong> 500 XP</p>
            <p>‚ú® <strong>2 Same:</strong> 50 XP</p>
          </div>
        </div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareSlotsAchievement()">
            üé∞ Share Slots Win
          </button>
        </div>
      </div>

      <!-- Dog Fortune Wheel Tab -->
      <div id="wheel" class="tab-content">
        <h3>üéØ Dog Fortune Wheel</h3>
        <p style="margin-bottom: 20px;">Spin the wheel and win tasty rewards!</p>
        
        <div class="wheel-container">
          <!-- √áarkƒ±n merkezi - K√∂pek logosu -->
          <div class="wheel-center">
            <div class="dog-logo">üêï</div>
          </div>
          
          <!-- D√∂nen √ßark -->
          <canvas id="wheelCanvas" width="350" height="350"></canvas>
          
          <!-- Ok i≈üareti -->
          <div class="wheel-pointer">‚ñº</div>
        </div>
        
        <div class="wheel-info">
          <div class="spin-cost">
            <span>üé´ 1 Spin = 0.05 MONAD</span>
          </div>
        </div>
        
        <button class="wheel-button" id="spinButton" onclick="spinWheel()">
          üéØ Spin the Wheel
        </button>
        
        <div id="wheel-status" class="status"></div>
        
        <!-- Prize Legend -->
        <div class="prize-legend">
          <h4 style="margin-bottom: 10px;">üèÜ Prize Pool</h4>
          <div class="prize-grid">
            <div class="prize-item">
              <span class="prize-emoji">ü¶¥ Golden Bone</span>
              <span class="prize-xp">10000 XP</span>
            </div>
            <div class="prize-item">
              <span class="prize-emoji">ü•© Juicy Steak</span>
              <span class="prize-xp">2000 XP</span>
            </div>
            <div class="prize-item">
              <span class="prize-emoji">üçñ Big Meat</span>
              <span class="prize-xp">500 XP</span>
            </div>
            <div class="prize-item">
              <span class="prize-emoji">ü¶¥ Lucky Bone</span>
              <span class="prize-xp">100 XP</span>
            </div>
            <div class="prize-item">
              <span class="prize-emoji">üç™ Dog Treat</span>
              <span class="prize-xp">50 XP</span>
            </div>
            <div class="prize-item">
              <span class="prize-emoji">üí§ Nap Time</span>
              <span class="prize-xp">10 XP</span>
            </div>
          </div>
        </div>
        
        <!-- Recent Big Wins -->
        <div class="recent-wins">
          <h4>üèÜ Recent Big Wins</h4>
          <div id="recentWinsList"></div>
        </div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareWheelAchievement()">
            üéØ Share Fortune Win
          </button>
        </div>
      </div>

      <!-- Claim Tab -->
      <div id="claim" class="tab-content">
        <h3>Claim $DOG Tokens</h3>
        <p style="margin-bottom: 20px;">Convert your earned XP to $DOG tokens!</p>
        
        <div class="claim-section">
          <div class="claim-info">
            <div class="claim-info-item">
              <div class="claim-info-label">Available XP</div>
              <div class="claim-info-value" id="claimableXP">0</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">‚Üí</div>
              <div style="font-size: 30px;">üîÑ</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">$DOG Tokens</div>
              <div class="claim-info-value" id="claimableDOG">0</div>
            </div>
          </div>
          
          <button class="claim-button" id="claimButton" onclick="claimTokens()" disabled>
            üí∞ Claim $DOG Tokens
          </button>
          
          <div class="conversion-rate">
            Conversion Rate: 10 XP = 1 $DOG Token
          </div>
          
          <div id="claim-status" class="status"></div>
        </div>
        
        <!-- Token Info -->
        <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 12px;">
          <div style="text-align: center; margin-bottom: 15px;">
            <h4 style="margin-bottom: 10px;">üêï $DOG Token Info</h4>
            <p style="font-size: 12px; opacity: 0.7;">Claim your tokens and they'll be minted directly to your wallet</p>
          </div>
          
          <!-- Wallet DOG Balance Display -->
          <div style="background: linear-gradient(135deg, #f59e0b, #eab308); padding: 20px; border-radius: 12px; text-align: center; margin: 15px 0;">
            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Your Wallet Balance</div>
            <div style="font-size: 32px; font-weight: 700;">
              <span id="walletDogDisplay">0</span> $DOG
            </div>
            <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">ü™ô Monad Testnet</div>
          </div>
          
          <div style="margin-top: 15px; text-align: center;">
            <a href="https://testnet.monadscan.com/address/0x1f6649d028c4c146c050a9b224115a01c92a02f3" 
               target="_blank" 
               class="share-button" 
               style="background: rgba(255,255,255,0.1); font-size: 12px; padding: 8px 16px;">
              üîç View Token Contract
            </a>
          </div>
        </div>
      </div>
    </div>

    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Monad Dog...</div>
      <div class="loading-subtitle">Starting Monad Dog...<br>üöÄ Initializing blockchain connection</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loadingProgressBar"></div>
      </div>
    </div>

    <!-- Achievement Modal -->
    <div id="achievementModal" class="achievement-modal" onclick="if(event.target === this) closeAchievementModal()">
      <div class="achievement-content">
        <button class="close-modal" onclick="closeAchievementModal()">√ó</button>
        <div id="achievementIcon" class="achievement-icon">üéâ</div>
        <h3 id="achievementTitle">Achievement Unlocked!</h3>
        <p id="achievementDescription">You did something awesome!</p>
        <div style="margin-top: 20px;">
          <button class="share-button" onclick="shareCurrentAchievement()">
            üì¢ Share on Farcaster
          </button>
          <button class="share-button" onclick="closeAchievementModal()" style="background: rgba(255,255,255,0.2);">
            ‚ú® Continue Playing
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Wait for Supabase to load
    window.addEventListener('DOMContentLoaded', function() {
      // Supabase Configuration
      const SUPABASE_URL = 'https://uhqszfoekqrjtybrwqzt.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVocXN6Zm9la3FyanR5YnJ3cXp0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4MDMxNTAsImV4cCI6MjA2NjM3OTE1MH0.gGch8B6AlvGrZTDVjfd0xidVnh_Dsua4qRxbaixBqM0';
      
      // Initialize Supabase
      let supabaseClient;
      if (window.supabase) {
        const { createClient } = window.supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ Supabase initialized');
        
        // Test connection after initialization
        setTimeout(async () => {
          console.log('üîç Testing Supabase connection...');
          const isConnected = await testSupabaseConnection();
          
          if (!isConnected) {
            console.warn('‚ö†Ô∏è Supabase connection failed, will use localStorage only');
          }
          
          // Make test and debug functions available globally
          window.testSupabaseConnection = testSupabaseConnection;
          window.debugSupabase = debugSupabase;
        }, 1000);
      } else {
        console.error('‚ùå Supabase not loaded');
      }
    
      // Initialize modal close functions globally
      window.closeAchievementModal = function() {
        const modal = document.getElementById('achievementModal');
        if (modal) {
          modal.style.display = 'none';
        }
        window.currentAchievement = null;
        
        // Remove escape key listener
        if (window.achievementEscapeHandler) {
          document.removeEventListener('keydown', window.achievementEscapeHandler);
        }
        
        console.log('Modal closed');
      }
      
      window.shareCurrentAchievement = function() {
        if (window.currentAchievement) {
          try {
            const content = generateShareableContent(window.currentAchievement.type, window.currentAchievement.data);
            shareOnFarcaster(content);
            
            // Close modal after sharing
            setTimeout(() => {
              closeAchievementModal();
            }, 500);
          } catch (error) {
            console.error('Error sharing achievement:', error);
            closeAchievementModal();
          }
        }
      }
      
      console.log('üöÄ Starting app...');

    // Enhanced Loading Management
    let loadingProgress = 0;
    let isAppReady = false;
    let activeTab = 'pet';

    function updateLoadingProgress(progress, message) {
      const progressBar = document.getElementById('loadingProgressBar');
      const subtitle = document.querySelector('.loading-subtitle');
      
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      if (subtitle && message) {
        subtitle.innerHTML = message;
      }
      
      loadingProgress = progress;
      console.log(`üìä Loading progress: ${progress}% - ${message}`);
    }

    function showLoadingState() {
      document.getElementById('loading').style.display = 'flex';
      document.querySelector('.app-content').classList.remove('loaded');
      updateLoadingProgress(0, 'Starting Monad Dog...<br>üöÄ Initializing blockchain connection');
    }

    function hideLoadingState() {
      // Don't hide immediately - show completion
      updateLoadingProgress(100, 'Ready to play! üéâ<br>Welcome to Monad Dog!');
      
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.querySelector('.app-content').classList.add('loaded');
        isAppReady = true;
        
        // Call Farcaster ready action
        if (sdk && sdk.actions && sdk.actions.ready) {
          sdk.actions.ready({
            disableNativeGestures: false // Allow native gestures for better UX
          }).then(() => {
            console.log('‚úÖ Farcaster SDK ready called successfully');
          }).catch(error => {
            console.log('‚ö†Ô∏è Farcaster SDK ready failed:', error);
          });
        }
        
        console.log('üéâ App fully loaded and ready');
      }, 500);
    }

    // Contract addresses and ABIs
    const CONTRACTS = {
      PET: "0xc53abe4c593b9440407f8ac1b346f3f999e6d8ed",
      GREET: "0xbc8b78f3e2348d4b5e0390fe700ce54b59931da4",
      FLIP: "0xc5b2280d1e2f155f9a2be2af7e78190658874106",
      SLOTS: "0xc7011f245aa51fa488783d5b0cfc6e0cba86f6cb",
      WHEEL: "0x0000000000000000000000000000000000000000", // TODO: Deploy wheel contract
      DOG_TOKEN: "0x1f6649d028c4c146c050a9b224115a01c92a02f3"
    };

    const ABIS = {
      PET: ["function pet() public"],
      GREET: ["function gm() public", "function gn() public"],
      FLIP: ["function flip() public"],
      SLOTS: [
        "function buyCredits() external payable",
        "function playSlots() external returns (uint8[4])",
        "function getCredits(address player) external view returns (uint256)",
        "function getGameStats() external view returns (uint256, uint256, uint256)",
        "event CreditsPurchased(address indexed player, uint256 credits, uint256 cost)",
        "event GamePlayed(address indexed player, uint8[4] results, uint256 creditsRemaining)",
        "event Jackpot(address indexed player, uint8 symbol, uint256 prize)"
      ],
      WHEEL: [
        "function spin() external payable returns (uint8)",
        "event WheelSpun(address indexed player, uint8 result, uint256 prize)"
      ],
      DOG_TOKEN: [
        "function claim(uint256 xpAmount) public",
        "function balanceOf(address account) public view returns (uint256)",
        "function decimals() public view returns (uint8)",
        "function symbol() public view returns (string)",
        "function totalSupply() public view returns (uint256)",
        "function getClaimedXP(address user) public view returns (uint256)",
        "function totalMinted() public view returns (uint256)",
        "event TokensClaimed(address indexed user, uint256 xpAmount, uint256 tokenAmount)"
      ]
    };

    // XP to DOG token conversion rate
    const XP_TO_DOG_RATE = 10; // 10 XP = 1 DOG token

    // Wheel game configuration
    const wheelSegments = [
      { emoji: 'ü¶¥', name: 'Golden Bone', chance: 1, xp: 10000, color: '#FFD700' },     // JACKPOT %1
      { emoji: 'ü•©', name: 'Juicy Steak', chance: 5, xp: 2000, color: '#8B4513' },      // Mega Win %5
      { emoji: 'üçñ', name: 'Big Meat', chance: 10, xp: 500, color: '#D2691E' },         // Big Win %10
      { emoji: 'ü¶¥', name: 'Lucky Bone', chance: 20, xp: 100, color: '#F4A460' },       // Win %20
      { emoji: 'üç™', name: 'Dog Treat', chance: 30, xp: 50, color: '#DEB887' },         // Small Win %30
      { emoji: 'üí§', name: 'Nap Time', chance: 34, xp: 10, color: '#708090' }           // Try Again %34
    ];

    // Wheel state
    let wheelState = {
      isSpinning: false,
      currentRotation: 0,
      segments: wheelSegments
    };

    // Global state 
    let appState = {
      connected: false,
      address: null,
      xp: 0, // Available XP (can be used for claiming)
      slotsCredits: 0, // Available slots game credits
      provider: null,
      signer: null,
      isTransactionPending: false
    };

    // Initialize SDK
    let sdk = null;
    
    // Supabase Functions for XP Management - FIXED VERSION
    async function getWalletXP(address) {
      if (!address) return 0;
      
      try {
        // Check if Supabase is available
        if (!supabaseClient) {
          console.error('‚ùå Supabase client not initialized');
          const localXP = parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
          console.log(`üì¶ Using localStorage XP: ${localXP}`);
          return localXP;
        }

        // Try to get from Supabase
        const { data, error } = await supabaseClient
          .from('user_xp')
          .select('xp')
          .eq('wallet_address', address.toLowerCase())
          .maybeSingle(); // Use maybeSingle instead of single to avoid error when no record

        if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
          console.error('‚ùå Supabase fetch error:', error);
          // Fallback to localStorage
          const localXP = parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
          console.log(`üì¶ Error occurred, using localStorage XP: ${localXP}`);
          return localXP;
        }
        
        if (!data) {
          console.log('üìù No XP record in Supabase, returning 0');
          return 0;
        }
        
        console.log(`‚úÖ Fetched XP from Supabase: ${data.xp}`);
        // Also update localStorage for consistency
        localStorage.setItem(`wallet_xp_${address.toLowerCase()}`, data.xp.toString());
        
        return data.xp || 0;
      } catch (e) {
        console.error('‚ùå Error fetching XP:', e);
        // Fallback to localStorage
        const localXP = parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
        console.log(`üì¶ Exception occurred, using localStorage XP: ${localXP}`);
        return localXP;
      }
    }

    async function saveWalletXP(address, xp) {
      if (!address) {
        console.error('‚ùå No address provided for saving XP');
        return;
      }
      
      // Always save to localStorage first (immediate)
      localStorage.setItem(`wallet_xp_${address.toLowerCase()}`, xp.toString());
      console.log(`üíæ XP saved to localStorage: ${xp}`);
      
      // Check if Supabase is available
      if (!supabaseClient) {
        console.error('‚ùå Supabase client not initialized, only saved to localStorage');
        return;
      }
      
      try {
        // Try to save to Supabase
        const { data, error } = await supabaseClient
          .from('user_xp')
          .upsert(
            {
              wallet_address: address.toLowerCase(),
              xp: xp,
              updated_at: new Date().toISOString()
            },
            {
              onConflict: 'wallet_address', // Specify the unique column
              ignoreDuplicates: false // Ensure update happens
            }
          )
          .select(); // Return the data to verify
        
        if (error) {
          console.error('‚ùå Supabase save error:', error);
          console.error('Error details:', {
            code: error.code,
            message: error.message,
            details: error.details,
            hint: error.hint
          });
        } else {
          console.log(`‚úÖ XP saved to Supabase successfully:`, data);
        }
      } catch (e) {
        console.error('‚ùå Exception saving XP to Supabase:', e);
      }
    }

    // Test function to verify Supabase connection
    async function testSupabaseConnection() {
      if (!supabaseClient) {
        console.error('‚ùå Supabase client not initialized');
        return false;
      }
      
      try {
        // Try a simple query
        const { data, error } = await supabaseClient
          .from('user_xp')
          .select('count')
          .limit(1);
        
        if (error) {
          console.error('‚ùå Supabase connection test failed:', error);
          return false;
        }
        
        console.log('‚úÖ Supabase connection test successful');
        return true;
      } catch (e) {
        console.error('‚ùå Supabase connection test exception:', e);
        return false;
      }
    }

    // Debug function to check Supabase data
    async function debugSupabase(address) {
      if (!supabaseClient) {
        console.error('‚ùå Supabase not initialized');
        return;
      }
      
      console.log('üîç Debugging Supabase for address:', address);
      
      try {
        // Check if table exists and is accessible
        const { data: tableData, error: tableError } = await supabaseClient
          .from('user_xp')
          .select('*')
          .limit(5);
        
        if (tableError) {
          console.error('‚ùå Cannot access user_xp table:', tableError);
          return;
        }
        
        console.log('‚úÖ Table accessible, sample data:', tableData);
        
        // Check specific user
        if (address) {
          const { data: userData, error: userError } = await supabaseClient
            .from('user_xp')
            .select('*')
            .eq('wallet_address', address.toLowerCase());
          
          if (userError) {
            console.error('‚ùå Error fetching user data:', userError);
          } else {
            console.log('üë§ User data:', userData);
          }
        }
        
      } catch (e) {
        console.error('‚ùå Debug exception:', e);
      }
    }

    // ‚úÖ SLOTS CREDITS MANAGEMENT - Updated with real contract integration
    async function getSlotsCredits(address) {
      if (!address || !appState.provider) return 0;
      
      try {
        // Get credits from smart contract
        const slotsContract = new ethers.Contract(
          CONTRACTS.SLOTS,
          ABIS.SLOTS,
          appState.provider
        );
        
        const credits = await slotsContract.getCredits(address);
        return credits.toNumber();
      } catch (e) {
        console.error('Error fetching slots credits from contract:', e);
        // Fallback to localStorage
        return parseInt(localStorage.getItem(`slots_credits_${address.toLowerCase()}`) || '0');
      }
    }

    async function saveSlotsCredits(address, credits) {
      if (!address) return;
      
      // Save to localStorage for immediate display
      localStorage.setItem(`slots_credits_${address.toLowerCase()}`, credits.toString());
      
      // Note: Actual credits are managed by smart contract
      // This is just for UI consistency
    }

    async function updateSlotsCreditsDisplay() {
      if (appState.connected && appState.address) {
        const credits = await getSlotsCredits(appState.address);
        appState.slotsCredits = credits;
        
        // Update slots button text
        updateSlotsButton();
        
        console.log(`üé∞ Slots Credits - Available: ${credits}`);
      } else {
        appState.slotsCredits = 0;
        updateSlotsButton();
      }
    }

    function updateSlotsButton() {
      const slotsButton = document.getElementById('slotsButton');
      if (!slotsButton) return;
      
      if (appState.slotsCredits > 0) {
        slotsButton.textContent = `üé∞ Play Slots (${appState.slotsCredits} credits)`;
        slotsButton.disabled = false;
      } else if (appState.connected) {
        slotsButton.textContent = `üí∞ Buy 2 Credits (0.1 MONAD)`;
        slotsButton.disabled = false;
      } else {
        slotsButton.textContent = `üîí Connect Wallet`;
        slotsButton.disabled = true;
      }
    }

    // Update wheel button based on connection state
    function updateWheelButton() {
      const spinButton = document.getElementById('spinButton');
      if (!spinButton) return;
      
      if (appState.connected) {
        spinButton.textContent = 'üéØ Spin the Wheel';
        spinButton.disabled = false;
      } else {
        spinButton.textContent = 'üîí Connect Wallet';
        spinButton.disabled = true;
      }
    }

    async function updateXPDisplay() {
      if (appState.connected && appState.address) {
        // Show current value immediately
        const currentDisplay = document.getElementById('xp').textContent;
        
        // Get XP (with timeout to prevent hanging)
        const xpPromise = getWalletXP(appState.address);
        const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(parseInt(currentDisplay) || 0), 1000));
        
        const walletXP = await Promise.race([xpPromise, timeoutPromise]);
        
        document.getElementById('xp').textContent = walletXP;
        appState.xp = walletXP;
        
        // Also update slots credits
        await updateSlotsCreditsDisplay();
        
        console.log(`üìä XP Display - Available: ${walletXP}`);
        
        // Update claim UI non-blocking
        if (activeTab === 'claim') {
          requestAnimationFrame(() => updateClaimUI());
        }
      } else {
        document.getElementById('xp').textContent = '0';
        appState.xp = 0;
        appState.slotsCredits = 0;
        updateClaimUI();
        updateSlotsButton();
        updateWheelButton();
      }
    }

    // Update claim UI based on current XP
    async function updateClaimUI() {
      const claimableXP = appState.xp || 0;
      const claimableDOG = Math.floor(claimableXP / XP_TO_DOG_RATE);
      
      document.getElementById('claimableXP').textContent = claimableXP;
      document.getElementById('claimableDOG').textContent = claimableDOG;
      
      const claimButton = document.getElementById('claimButton');
      if (claimableXP >= XP_TO_DOG_RATE && appState.connected) {
        claimButton.disabled = false;
        claimButton.textContent = `üí∞ Claim ${claimableDOG} $DOG Tokens`;
      } else {
        claimButton.disabled = true;
        if (!appState.connected) {
          claimButton.textContent = 'üîí Connect Wallet First';
        } else if (claimableXP < XP_TO_DOG_RATE) {
          claimButton.textContent = `üìà Need ${XP_TO_DOG_RATE - claimableXP} more XP`;
        }
      }
      
      // Update token balance
      await updateTokenBalance();
    }

    // Update token balance display
    async function updateTokenBalance() {
      if (!appState.connected || !appState.provider || !appState.address) {
        console.log('‚ùå Not connected, cannot fetch balance');
        document.getElementById('walletDogDisplay').textContent = '0';
        return;
      }
      
      console.log('üîÑ Fetching DOG balance for:', appState.address);
      
      try {
        // Check if we're using Farcaster wallet
        const isFarcasterWallet = sdk && sdk.wallet && sdk.wallet.ethProvider;
        
        if (isFarcasterWallet) {
          console.log('üü£ Using Farcaster wallet - trying direct RPC call');
          
          try {
            // Encode the balanceOf function call
            const iface = new ethers.utils.Interface([
              "function balanceOf(address account) public view returns (uint256)"
            ]);
            const data = iface.encodeFunctionData("balanceOf", [appState.address]);
            
            // Make the call using the provider's send method
            const result = await appState.provider.send("eth_call", [{
              to: CONTRACTS.DOG_TOKEN,
              data: data
            }, "latest"]);
            
            console.log('Raw result:', result);
            
            if (result && result !== '0x') {
              const balance = ethers.BigNumber.from(result);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`‚úÖ DOG Balance (Farcaster): ${displayBalance}`);
            } else {
              console.log('No balance or contract not found');
              document.getElementById('walletDogDisplay').textContent = '0';
            }
            
          } catch (callError) {
            console.error('Direct eth_call failed:', callError);
            
            // Fallback: Try using a public RPC endpoint
            console.log('Trying fallback RPC...');
            try {
              const fallbackProvider = new ethers.providers.JsonRpcProvider('https://testnet-rpc.monad.xyz');
              const dogTokenContract = new ethers.Contract(
                CONTRACTS.DOG_TOKEN,
                ["function balanceOf(address) view returns (uint256)"],
                fallbackProvider
              );
              
              const balance = await dogTokenContract.balanceOf(appState.address);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`‚úÖ DOG Balance (Fallback RPC): ${displayBalance}`);
              
            } catch (fallbackError) {
              console.error('Fallback RPC also failed:', fallbackError);
              document.getElementById('walletDogDisplay').textContent = '0';
            }
          }
          
        } else {
          // Regular wallet (MetaMask, etc.)
          console.log('ü¶ä Using regular wallet provider');
          
          const dogTokenContract = new ethers.Contract(
            CONTRACTS.DOG_TOKEN,
            ["function balanceOf(address) view returns (uint256)"],
            appState.provider
          );
          
          const balance = await dogTokenContract.balanceOf(appState.address);
          const formattedBalance = ethers.utils.formatUnits(balance, 18);
          const numBalance = parseFloat(formattedBalance);
          const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                               numBalance > 0 ? numBalance.toFixed(6) : '0';
          
          document.getElementById('walletDogDisplay').textContent = displayBalance;
          console.log(`‚úÖ DOG Balance: ${displayBalance}`);
        }
        
      } catch (error) {
        console.error('‚ùå Error fetching token balance:', error);
        
        // Last resort: Use localStorage cache if available
        const cachedBalance = localStorage.getItem(`dog_balance_${appState.address.toLowerCase()}`);
        if (cachedBalance) {
          document.getElementById('walletDogDisplay').textContent = cachedBalance;
          console.log(`üì¶ Using cached balance: ${cachedBalance}`);
        } else {
          document.getElementById('walletDogDisplay').textContent = '0';
        }
      }
    }

    // ‚úÖ FIXED CLAIM FUNCTION - XP resets after user confirms transaction + Button cooldown
    window.claimTokens = async function() {
      if (!appState.connected || !appState.signer) {
        showError('Please connect your wallet first');
        return;
      }
      
      const availableXP = appState.xp;
      const claimableDOG = Math.floor(availableXP / XP_TO_DOG_RATE);
      
      if (availableXP < XP_TO_DOG_RATE) {
        showError(`Need at least ${XP_TO_DOG_RATE} XP to claim tokens`);
        return;
      }
      
      const claimButton = document.getElementById('claimButton');
      
      try {
        console.log('üí∞ Starting token claim...');
        
        // ‚úÖ Disable button immediately for 30 seconds
        claimButton.disabled = true;
        
        // Start countdown
        let countdown = 30;
        const originalText = claimButton.textContent;
        
        const countdownInterval = setInterval(() => {
          countdown--;
          claimButton.textContent = `‚è≥ Please wait ${countdown}s...`;
          
          if (countdown <= 0) {
            clearInterval(countdownInterval);
            // Re-enable button and update text after countdown
            updateClaimUI();
          }
        }, 1000);
        
        showStatus('claim-status', 'üîê Please confirm transaction in your wallet...', 'pending');
        
        // Ensure correct network
        await ensureMonadNetwork();
        
        // Call the actual DOG token contract
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          ABIS.DOG_TOKEN,
          appState.signer
        );
        
        // Calculate XP to claim (must be multiple of 10)
        const xpToClaim = claimableDOG * XP_TO_DOG_RATE;
        
        console.log(`Claiming ${xpToClaim} XP for ${claimableDOG} DOG tokens`);
        
        // Execute claim transaction with proper gas limit
        const tx = await dogTokenContract.claim(xpToClaim, {
          gasLimit: 100000
        });
        
        // ‚úÖ USER CONFIRMED TRANSACTION - NOW RESET XP IMMEDIATELY
        console.log('üéØ Transaction confirmed by user - resetting XP to 0');
        
        // Reset XP to 0 in state and display immediately
        appState.xp = 0;
        document.getElementById('xp').textContent = '0';
        
        // ‚úÖ Save XP as 0 to Supabase immediately
        await saveWalletXP(appState.address, 0);
        
        // Update claim UI immediately
        await updateClaimUI();
        
        showStatus('claim-status', `üì° Transaction sent: ${tx.hash.slice(0,10)}... XP reset to 0`, 'pending');
        console.log('Transaction hash:', tx.hash);
        console.log('‚úÖ XP successfully reset to 0 - user can continue earning');
        
        // Wait for confirmation and update balance
        setTimeout(async () => {
          try {
            // Try to get updated balance with multiple retries
            const updateBalanceWithRetry = async (retries = 3) => {
              for (let i = 0; i < retries; i++) {
                try {
                  await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                  
                  const newBalance = await dogTokenContract.balanceOf(appState.address);
                  const decimals = await dogTokenContract.decimals();
                  const formattedBalance = ethers.utils.formatUnits(newBalance, decimals);
                  
                  const numBalance = parseFloat(formattedBalance);
                  const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : numBalance.toFixed(6);
                  
                  document.getElementById('walletDogDisplay').textContent = displayBalance;
                  
                  // Cache the balance
                  localStorage.setItem(`dog_balance_${appState.address.toLowerCase()}`, displayBalance);
                  
                  console.log(`‚úÖ Balance updated after claim (attempt ${i + 1}): ${displayBalance} DOG`);
                  break;
                } catch (e) {
                  console.log(`Balance update attempt ${i + 1} failed, retrying...`);
                }
              }
            };
            
            updateBalanceWithRetry();
            
            showStatus('claim-status', `‚úÖ Successfully claimed ${claimableDOG} $DOG tokens! XP reset - start earning again!`, 'success');
            
            // Show achievement
            showAchievementModal({
              icon: 'üí∞',
              title: 'Tokens Claimed!',
              description: `You've successfully claimed ${claimableDOG} $DOG tokens! Your XP has been reset - start earning again!`,
              type: 'claim',
              data: { amount: claimableDOG }
            });
            
            setTimeout(() => hideStatus('claim-status'), 8000);
            
          } catch (e) {
            console.log('Post-claim update error:', e);
            showStatus('claim-status', `‚úÖ Claim transaction sent! Tokens will arrive soon. XP reset successfully.`, 'success');
            setTimeout(() => hideStatus('claim-status'), 8000);
          }
        }, 5000);
        
      } catch (error) {
        console.error('‚ùå Claim error:', error);
        
        let errorMsg = 'Failed to claim tokens';
        
        if (error.message.includes('user rejected')) {
          errorMsg = 'Transaction cancelled - XP not affected';
          // Don't reset XP if user cancelled
          console.log('üö´ Transaction cancelled - XP remains unchanged');
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient gas funds';
        } else if (error.message.includes('XP already claimed')) {
          errorMsg = 'This XP has already been claimed';
          // Reset XP if already claimed on contract
          appState.xp = 0;
          await saveWalletXP(appState.address, 0);
          await updateXPDisplay();
        } else if (error.message.includes('Invalid XP amount')) {
          errorMsg = 'Invalid XP amount. Must be multiple of 10';
        }
        
        showStatus('claim-status', errorMsg, 'error');
        setTimeout(() => hideStatus('claim-status'), 5000);
      }
    };

    // Draw the fortune wheel
    function drawWheel() {
      const canvas = document.getElementById('wheelCanvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 160;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Calculate segment angle
      const totalSegments = wheelState.segments.length;
      const anglePerSegment = (2 * Math.PI) / totalSegments;
      
      wheelState.segments.forEach((segment, index) => {
        // Draw segment
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(
          centerX, 
          centerY, 
          radius, 
          index * anglePerSegment + wheelState.currentRotation,
          (index + 1) * anglePerSegment + wheelState.currentRotation
        );
        ctx.closePath();
        ctx.fillStyle = segment.color;
        ctx.fill();
        
        // Draw border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw emoji and text
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate((index + 0.5) * anglePerSegment + wheelState.currentRotation);
        
        // Emoji
        ctx.font = '30px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(segment.emoji, radius * 0.7, 10);
        
        // XP text
        ctx.font = '16px Arial';
        ctx.fillText(`${segment.xp} XP`, radius * 0.7, 35);
        
        ctx.restore();
      });
    }

    // Spin the wheel function
    window.spinWheel = async function() {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }
      
      if (wheelState.isSpinning) {
        return;
      }
      
      const spinButton = document.getElementById('spinButton');
      
      try {
        wheelState.isSpinning = true;
        spinButton.disabled = true;
        spinButton.textContent = 'üéØ Spinning...';
        
        showStatus('wheel-status', 'üîê Please confirm 0.05 MONAD payment...', 'pending');
        
        // Ensure correct network
        await ensureMonadNetwork();
        
        // For now, simulate the transaction (replace with actual contract call when deployed)
        if (CONTRACTS.WHEEL === "0x0000000000000000000000000000000000000000") {
          // Simulate payment
          console.log('‚ö†Ô∏è Wheel contract not deployed yet, simulating...');
          
          // Simulate transaction delay
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          showStatus('wheel-status', 'üéØ Wheel is spinning...', 'pending');
          
          // Calculate result based on chances
          const resultIndex = calculateWheelResult();
          startWheelAnimation(resultIndex);
          
        } else {
          // Real contract interaction
          const wheelContract = new ethers.Contract(
            CONTRACTS.WHEEL,
            ABIS.WHEEL,
            appState.signer
          );
          
          const tx = await wheelContract.spin({
            value: ethers.utils.parseEther("0.05"),
            gasLimit: 150000
          });
          
          showStatus('wheel-status', 'üéØ Wheel is spinning...', 'pending');
          
          // Start spinning animation
          const resultIndex = calculateWheelResult(); // In real implementation, get from contract event
          startWheelAnimation(resultIndex);
        }
        
      } catch (error) {
        console.error('Spin error:', error);
        wheelState.isSpinning = false;
        spinButton.disabled = false;
        spinButton.textContent = 'üéØ Spin the Wheel';
        
        let errorMsg = 'Spin failed';
        if (error.message.includes('user rejected')) {
          errorMsg = 'Payment cancelled';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient MONAD balance';
        }
        
        showStatus('wheel-status', errorMsg, 'error');
        setTimeout(() => hideStatus('wheel-status'), 5000);
      }
    }

    // Calculate wheel result based on chances
    function calculateWheelResult() {
      const random = Math.random() * 100;
      let cumulative = 0;
      
      for (let i = 0; i < wheelState.segments.length; i++) {
        cumulative += wheelState.segments[i].chance;
        if (random <= cumulative) {
          return i;
        }
      }
      
      return wheelState.segments.length - 1; // Default to last segment
    }

    // Start wheel spinning animation
    function startWheelAnimation(resultIndex) {
      const spins = 5 + Math.random() * 5; // 5-10 full rotations
      const duration = 4000; // 4 seconds
      const startTime = Date.now();
      const startRotation = wheelState.currentRotation;
      
      // Calculate target rotation to land on result
      const segmentAngle = (2 * Math.PI) / wheelState.segments.length;
      const targetRotation = startRotation + (spins * 2 * Math.PI) - (resultIndex * segmentAngle) - (segmentAngle / 2);
      
      // Animation loop
      function animate() {
        const now = Date.now();
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function for realistic spin
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        wheelState.currentRotation = startRotation + (targetRotation - startRotation) * easeOut;
        drawWheel();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Spin complete
          onWheelSpinComplete(resultIndex);
        }
      }
      
      animate();
    }

    // Handle wheel spin completion
    function onWheelSpinComplete(resultIndex) {
      const result = wheelState.segments[resultIndex];
      
      // Award XP
      addXP(result.xp);
      
      // Update UI
      wheelState.isSpinning = false;
      const spinButton = document.getElementById('spinButton');
      spinButton.disabled = false;
      spinButton.textContent = 'üéØ Spin Again';
      
      // Show result
      if (result.xp >= 2000) {
        // Big win animation
        showStatus('wheel-status', `üéâ ${result.name}! You won ${result.xp} XP!`, 'success');
        
        // Show achievement modal for big wins
        showAchievementModal({
          icon: result.emoji,
          title: 'BIG WIN!',
          description: `Amazing! You got the ${result.name} and won ${result.xp} XP!`,
          type: 'wheel',
          data: { prize: result.name, xp: result.xp }
        });
        
        // Add to recent wins
        addToRecentWins(appState.address, result);
        
      } else if (result.xp >= 100) {
        showStatus('wheel-status', `‚ú® ${result.name}! +${result.xp} XP`, 'success');
      } else {
        showStatus('wheel-status', `üí§ ${result.name}... +${result.xp} XP. Try again!`, 'error');
      }
      
      setTimeout(() => hideStatus('wheel-status'), 5000);
    }

    // Add to recent wins display
    function addToRecentWins(address, result) {
      if (result.xp < 500) return; // Only show big wins
      
      const winsList = document.getElementById('recentWinsList');
      const winItem = document.createElement('div');
      winItem.className = 'win-item';
      winItem.innerHTML = `
        <span>${address.slice(0,6)}...${address.slice(-4)}</span>
        <span>${result.emoji} ${result.name}</span>
        <span>${result.xp} XP</span>
      `;
      
      winsList.insertBefore(winItem, winsList.firstChild);
      
      // Keep only last 5 wins
      while (winsList.children.length > 5) {
        winsList.removeChild(winsList.lastChild);
      }
    }

    async function initializeAppWithProgress() {
      try {
        showLoadingState();
        
        // Step 1: Initialize SDK
        updateLoadingProgress(20, 'Loading Farcaster SDK...<br>üîó Connecting to Frame environment');
        
        try {
          const module = await import('https://esm.sh/@farcaster/frame-sdk');
          sdk = module.sdk;
          console.log('SDK loaded:', !!sdk);
          
          if (sdk) {
            updateLoadingProgress(40, 'Farcaster SDK loaded! ‚úÖ<br>üì± Setting up Mini App environment');
            await sdk.actions.ready();
            console.log('SDK ready');
          }
        } catch (e) {
          console.log('SDK not available:', e.message);
          updateLoadingProgress(40, 'Running in standalone mode<br>üåê Browser environment detected');
        }

        // Step 2: Setup game functions
        updateLoadingProgress(60, 'Setting up game functions...<br>üéÆ Preparing blockchain interactions');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        setupEventListeners();
        setupGameFunctions();
        
        // Step 3: Initialize wheel
        updateLoadingProgress(70, 'Initializing Fortune Wheel...<br>üéØ Drawing wheel segments');
        drawWheel();
        
        // Step 4: Initialize app
        updateLoadingProgress(80, 'Initializing app...<br>üéÆ Setting up games');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Step 5: Finalize
        updateLoadingProgress(95, 'Almost ready...<br>‚ú® Final preparations');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        hideLoadingState();
        console.log('‚úÖ App initialized successfully with progress tracking');
        
      } catch (error) {
        console.error('‚ùå Init error:', error);
        updateLoadingProgress(100, 'Error occurred, but app will continue<br>‚ö†Ô∏è Some features may be limited');
        
        setTimeout(() => {
          hideLoadingState();
        }, 1000);
      }
    }

    async function initApp() {
      await initializeAppWithProgress();
    }

    function setupEventListeners() {
      document.getElementById('connect-btn').onclick = connectWallet;
      document.getElementById('disconnect-btn').onclick = disconnect;
    }

    // Disable all action buttons during transaction
    function disableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = true;
          button.dataset.originalText = button.textContent;
        }
      });
      
      appState.isTransactionPending = true;
    }

    // Enable all action buttons after transaction
    function enableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = false;
          if (button.dataset.originalText) {
            button.textContent = button.dataset.originalText;
            delete button.dataset.originalText;
          }
        }
      });
      
      appState.isTransactionPending = false;
      
      // Update claim button state
      if (activeTab === 'claim') {
        updateClaimUI();
      }
    }

    function setupGameFunctions() {
      // Define all game functions globally
      window.petDog = async function() {
        console.log('üêï Pet Dog clicked!');
        
        if (!appState.connected) {
          console.log('‚ùå Wallet not connected');
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        console.log('‚úÖ Wallet connected, starting pet transaction');
        
        // Change dog image
        document.getElementById('dog-img').src = `https://placedog.net/400/300?id=${Math.floor(Math.random() * 50) + 1}`;
        
        // Execute real blockchain transaction
        await executeTransaction(
          CONTRACTS.PET,
          ABIS.PET,
          'pet',
          'pet-status',
          'üêï Dog petted successfully! +10 XP',
          10
        );
      };

      window.sayGM = async function() {
        console.log('‚òÄÔ∏è Say GM clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gm',
          'greet-status',
          '‚òÄÔ∏è Good Morning sent! +5 XP',
          5
        );
      };

      window.sayGN = async function() {
        console.log('üåô Say GN clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gn',
          'greet-status',
          'üåô Good Night sent! +5 XP',
          5
        );
      };

      window.flipCoin = async function() {
        console.log('ü™ô Flip Coin clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const coin = document.getElementById('coin');
        const result = document.getElementById('flip-result');
        
        // Start visual animation
        result.textContent = 'Flipping...';
        let rotation = 0;
        const interval = setInterval(() => {
          rotation += 180;
          coin.style.transform = `rotateY(${rotation}deg)`;
        }, 100);
        
        // Execute real transaction
        await executeTransaction(
          CONTRACTS.FLIP,
          ABIS.FLIP,
          'flip',
          'flip-status',
          'ü™ô Coin flipped! +3 XP',
          3
        );
        
        // Stop animation after transaction starts
        setTimeout(() => {
          clearInterval(interval);
          const finalResult = Math.random() < 0.5 ? 'Heads' : 'Tails';
          coin.style.transform = `rotateY(${finalResult === 'Heads' ? 0 : 180}deg)`;
          result.textContent = `Result: ${finalResult}!`;
        }, 3000);
      };

      // ‚úÖ SLOTS GAME FUNCTION - REDESIGNED WITH CREDITS SYSTEM
      window.playSlots = async function() {
        console.log('üé∞ Play Slots clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        // Check if user has credits or needs to buy
        if (appState.slotsCredits > 0) {
          // USE EXISTING CREDIT
          await playSlotGame();
        } else {
          // BUY CREDITS WITH 0.1 MONAD
          await buySlotCredits();
        }
      };

      // Buy slot credits with 0.1 MONAD payment - REAL CONTRACT VERSION
      async function buySlotCredits() {
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        try {
          // Disable button immediately
          slotsButton.disabled = true;
          slotsButton.textContent = 'üí∞ Buying Credits...';
          
          showStatus('slots-status', 'üîê Please confirm payment of 0.1 MONAD for 2 game credits...', 'pending');
          
          // Ensure correct network
          await ensureMonadNetwork();
          
          // ‚úÖ REAL CONTRACT CALL
          const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, ABIS.SLOTS, appState.signer);
          
          // Send transaction with 0.1 MONAD payment
          const tx = await slotsContract.buyCredits({
            value: ethers.utils.parseEther("0.1"), // 0.1 MONAD
            gasLimit: 100000
          });
          
          console.log('‚úÖ Credits purchase transaction sent:', tx.hash);
          showStatus('slots-status', `üì° Payment sent: ${tx.hash.slice(0,10)}... Waiting for confirmation...`, 'pending');
          
          // Wait for transaction confirmation
          setTimeout(async () => {
            try {
              // ‚úÖ GET CREDITS FROM CONTRACT
              const credits = await slotsContract.getCredits(appState.address);
              appState.slotsCredits = credits.toNumber();
              
              // Save to localStorage for immediate display
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              updateSlotsButton();
              
              showStatus('slots-status', `‚úÖ Payment confirmed! You have ${appState.slotsCredits} game credits!`, 'success');
              console.log(`‚úÖ ${appState.slotsCredits} slots credits confirmed from contract`);
              
              setTimeout(() => hideStatus('slots-status'), 3000);
            } catch (e) {
              console.error('Error getting credits after purchase:', e);
              // Fallback: assume 2 credits were added
              appState.slotsCredits += 2;
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              updateSlotsButton();
              
              showStatus('slots-status', '‚úÖ Payment confirmed! Credits should be available soon.', 'success');
              setTimeout(() => hideStatus('slots-status'), 3000);
            }
          }, 5000);
          
        } catch (error) {
          console.error('‚ùå Payment error:', error);
          
          slotsButton.disabled = false;
          slotsButton.textContent = originalText;
          
          let errorMsg = 'Payment failed';
          if (error.message.includes('user rejected')) {
            errorMsg = 'Payment cancelled';
          } else if (error.message.includes('insufficient funds')) {
            errorMsg = 'Insufficient MONAD balance';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Play the actual slot game using 1 credit - REAL CONTRACT VERSION
      async function playSlotGame() {
        if (appState.slotsCredits <= 0) {
          showError('No game credits available');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        
        try {
          // Disable button during game
          slotsButton.disabled = true;
          slotsButton.textContent = 'üé∞ Playing...';
          
          console.log(`üéÆ Playing slots with contract, current credits: ${appState.slotsCredits}`);
          showStatus('slots-status', 'üé∞ Spinning the reels...', 'pending');
          
          // ‚úÖ REAL CONTRACT CALL
          const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, ABIS.SLOTS, appState.signer);
          
          // Play slots on contract (uses 1 credit automatically)
          const tx = await slotsContract.playSlots({
            gasLimit: 150000
          });
          
          console.log('‚úÖ Slots game transaction sent:', tx.hash);
          
          // Start visual animation while waiting for result
          const symbols = ['üêï', 'ü¶Æ', 'üê∂', 'ü¶¥'];
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          
          // Spinning animation
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.add('spinning');
          });
          
          let spinDuration = 4000; // 4 seconds of spinning
          
          const spinInterval = setInterval(() => {
            reels.forEach(reelId => {
              const reel = document.getElementById(reelId);
              reel.textContent = symbols[Math.floor(Math.random() * symbols.length)];
            });
          }, 100);
          
          // Wait for transaction and get results
          setTimeout(async () => {
            clearInterval(spinInterval);
            
            try {
              // Get transaction receipt to see events
              const receipt = await appState.provider.getTransactionReceipt(tx.hash);
              
              // Parse game results from events (simplified - in real implementation you'd parse the event)
              // For now, generate results based on transaction hash for deterministic results
              const results = [];
              const txHash = tx.hash;
              for (let i = 0; i < 4; i++) {
                const byte = parseInt(txHash.slice(2 + i * 2, 4 + i * 2), 16);
                results.push(symbols[byte % 4]);
              }
              
              // Display final results
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Update credits from contract
              const newCredits = await slotsContract.getCredits(appState.address);
              appState.slotsCredits = newCredits.toNumber();
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              console.log(`üéÆ Game completed, remaining credits: ${appState.slotsCredits}`);
              
              // Check for winning combinations and award XP
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
              
            } catch (e) {
              console.error('Error processing game result:', e);
              
              // Fallback: Generate random results and update credits
              const results = [];
              for (let i = 0; i < 4; i++) {
                results.push(symbols[Math.floor(Math.random() * symbols.length)]);
              }
              
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Assume 1 credit was used
              appState.slotsCredits = Math.max(0, appState.slotsCredits - 1);
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
            }
          }, spinDuration);
          
        } catch (error) {
          console.error('‚ùå Game error:', error);
          
          // Stop spinning animation
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.remove('spinning');
          });
          
          updateSlotsButton();
          
          let errorMsg = 'Game failed';
          if (error.message.includes('No credits available')) {
            errorMsg = 'No credits available';
          } else if (error.message.includes('user rejected')) {
            errorMsg = 'Game cancelled';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Check slots winning combinations
      function checkSlotsWin(results) {
        console.log('üé∞ Slots results:', results);
        
        // Count occurrences of each symbol
        const symbolCounts = {};
        results.forEach(symbol => {
          symbolCounts[symbol] = (symbolCounts[symbol] || 0) + 1;
        });
        
        // Check for 4 of a kind (jackpot)
        const maxCount = Math.max(...Object.values(symbolCounts));
        
        if (maxCount === 4) {
          // JACKPOT! 4 of a kind
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 4);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 5000 XP
          addXP(5000);
          
          showStatus('slots-status', `üéâ JACKPOT! 4x ${winningSymbol} = +5000 XP!`, 'success');
          
          // Show jackpot achievement
          setTimeout(() => {
            showAchievementModal({
              icon: 'üé∞',
              title: 'JACKPOT WINNER!',
              description: `Amazing! You got 4x ${winningSymbol} and won 5000 XP! You're incredibly lucky!`,
              type: 'slots',
              data: { 
                symbol: winningSymbol, 
                count: 4, 
                xp: 5000,
                result: results.join('')
              }
            });
          }, 1000);
          
        } else if (maxCount === 3) {
          // 3 of a kind - smaller win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 3);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 500 XP for 3 of a kind
          addXP(500);
          
          showStatus('slots-status', `üèÜ 3x ${winningSymbol} = +500 XP!`, 'success');
          
        } else if (maxCount === 2) {
          // 2 of a kind - small win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 2);
          
          // Award 50 XP for 2 of a kind
          addXP(50);
          
          showStatus('slots-status', `‚ú® 2x ${winningSymbol} = +50 XP!`, 'success');
          
        } else {
          // No win
          showStatus('slots-status', 'üòî No match this time. Try again!', 'error');
        }
        
        // Clear status and winning highlights after delay
        setTimeout(() => {
          hideStatus('slots-status');
          document.querySelectorAll('.slot-reel').forEach(reel => {
            reel.classList.remove('winning');
          });
        }, 5000);
      }

      // Reset slots display
      function resetSlotsDisplay() {
        const symbols = ['üêï', 'ü¶Æ', 'üê∂', 'ü¶¥'];
        const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
        
        reels.forEach((reelId, index) => {
          const reel = document.getElementById(reelId);
          reel.textContent = symbols[index];
          reel.classList.remove('spinning', 'winning');
        });
      }

      window.showTab = function(tabName) {
        console.log('üìë Switching to tab:', tabName);
        activeTab = tabName;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
        
        // Update claim UI when switching to claim tab
        if (tabName === 'claim') {
          updateClaimUI();
          // Update balance with delay for better reliability
          setTimeout(() => {
            updateTokenBalance();
          }, 500);
        }
        
        // Update slots when switching to slots tab
        if (tabName === 'slots') {
          resetSlotsDisplay();
          updateSlotsButton();
        }
        
        // Update wheel when switching to wheel tab
        if (tabName === 'wheel') {
          drawWheel();
          updateWheelButton();
        }
      };
      
      console.log('üéÆ Game functions setup complete');
    }

    async function connectWallet() {
      try {
        console.log('Connecting wallet...');
        
        // Show loading state
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = 'üîÑ Connecting...';
        connectBtn.disabled = true;
        
        let provider;
        
        if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
          console.log('Using Farcaster wallet');
          provider = sdk.wallet.ethProvider;
        } else if (window.ethereum) {
          console.log('Using browser wallet');
          provider = window.ethereum;
        } else {
          throw new Error('No wallet available');
        }

        // Request accounts with timeout
        const accountsPromise = provider.request({
          method: 'eth_requestAccounts'
        });
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), 10000)
        );
        
        const accounts = await Promise.race([accountsPromise, timeoutPromise]);

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }

        console.log('‚úÖ Connected:', accounts[0]);

        // Setup ethers
        appState.provider = new ethers.providers.Web3Provider(provider);
        appState.signer = appState.provider.getSigner();
        appState.address = accounts[0];
        appState.connected = true;

        // Update UI and load wallet-specific data
        updateWalletUI();
        
        // Load data asynchronously
        updateXPDisplay().catch(console.error);
        
        // Ensure network is correct before fetching balance
        await ensureMonadNetwork();
        
        // Update token balance with multiple retries
        const fetchBalance = async () => {
          for (let i = 0; i < 3; i++) {
            try {
              await updateTokenBalance();
              break;
            } catch (e) {
              console.log(`Balance fetch attempt ${i + 1} failed, retrying...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          }
        };
        
        fetchBalance();

      } catch (error) {
        console.error('Connection error:', error);
        showError(error.message);
        
        // Reset button
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = 'üü£ Connect Wallet';
        connectBtn.disabled = false;
      }
    }

    async function disconnect() {
      appState = {
        connected: false,
        address: null,
        xp: 0,
        slotsCredits: 0,
        provider: null,
        signer: null
      };
      updateWalletUI();
      await updateXPDisplay();
      console.log('üîå Wallet disconnected, XP reset to 0');
    }

    function updateWalletUI() {
      const connectArea = document.getElementById('connect-area');
      const connectedArea = document.getElementById('connected-area');
      const addressEl = document.getElementById('address');

      if (appState.connected) {
        connectArea.style.display = 'none';
        connectedArea.style.display = 'block';
        addressEl.textContent = appState.address.slice(0,6) + '...' + appState.address.slice(-4);
      } else {
        connectArea.style.display = 'block';
        connectedArea.style.display = 'none';
      }
    }

    async function addXP(amount) {
      if (!appState.connected || !appState.address) {
        console.log('‚ùå Cannot add XP: wallet not connected');
        return;
      }
      
      console.log(`‚ûï Adding ${amount} XP to ${appState.address}`);
      
      // Add XP to current balance
      const previousXP = appState.xp || 0;
      appState.xp = previousXP + amount;
      
      // Update display immediately
      document.getElementById('xp').textContent = appState.xp;
      
      // Save XP with await to ensure it completes
      try {
        await saveWalletXP(appState.address, appState.xp);
        console.log(`‚ú® XP successfully updated: ${previousXP} ‚Üí ${appState.xp} (+${amount})`);
      } catch (error) {
        console.error('‚ùå Error saving XP:', error);
        // Even if save fails, the XP is already in localStorage
      }
      
      // Update claim UI non-blocking
      requestAnimationFrame(() => updateClaimUI());
      
      // Add celebration effect
      const xpElement = document.getElementById('xp');
      xpElement.style.transform = 'scale(1.2)';
      xpElement.style.color = '#00ff00';
      
      setTimeout(() => {
        xpElement.style.transform = 'scale(1)';
        xpElement.style.color = 'white';
      }, 500);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.className = `status visible ${type}`;
    }

    function hideStatus(id) {
      document.getElementById(id).className = 'status';
    }

    function showError(message) {
      const div = document.createElement('div');
      div.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:10px 20px;border-radius:8px;z-index:1000;';
      div.textContent = message;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Real transaction function
    async function executeTransaction(contractAddress, abi, methodName, statusId, successMsg, xpAmount) {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }

      if (appState.isTransactionPending) {
        showError('Please wait for the current transaction to complete');
        return;
      }

      try {
        console.log('üîó Starting transaction:', methodName);
        
        // Disable all action buttons
        disableAllActionButtons();
        
        showStatus(statusId, 'Preparing transaction...', 'pending');

        // Ensure Monad network
        await ensureMonadNetwork();

        // Create contract instance
        const contract = new ethers.Contract(contractAddress, abi, appState.signer);
        
        showStatus(statusId, 'üîê Please confirm in your wallet...', 'pending');

        // Send transaction
        const tx = await contract[methodName]({
          gasLimit: 100000
        });

        console.log('‚úÖ Transaction sent:', tx.hash);
        showStatus(statusId, `‚úÖ Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');

        // Since Farcaster wallet doesn't support eth_getTransactionReceipt,
        // we'll assume success after a delay
        setTimeout(async () => {
          console.log('‚úÖ Transaction assumed successful');
          showStatus(statusId, successMsg, 'success');
          await addXP(xpAmount);
          
          // Enable all buttons
          enableAllActionButtons();
          
          setTimeout(() => hideStatus(statusId), 3000);
        }, 5000);

      } catch (error) {
        console.error('‚ùå Transaction error:', error);
        
        // Enable all buttons on error
        enableAllActionButtons();
        
        let errorMsg = 'Transaction failed';
        if (error.message.includes('user rejected') || error.code === 4001) {
          errorMsg = 'Transaction cancelled by user';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient funds for gas';
        }

        showStatus(statusId, errorMsg, 'error');
        setTimeout(() => hideStatus(statusId), 5000);
      }
    }

    async function ensureMonadNetwork() {
      const MONAD_CHAIN_ID = '0x279F'; // 10143 in hex
      
      try {
        const provider = sdk && sdk.wallet && sdk.wallet.ethProvider 
          ? sdk.wallet.ethProvider 
          : window.ethereum;

        if (!provider) {
          throw new Error('No wallet provider available');
        }

        const chainId = await provider.request({ method: 'eth_chainId' });
        console.log('Current chain ID:', chainId);

        if (chainId !== MONAD_CHAIN_ID) {
          console.log('Switching to Monad Testnet...');
          
          try {
            await provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: MONAD_CHAIN_ID }],
            });
            console.log('Switched to Monad Testnet');
          } catch (switchError) {
            if (switchError.code === 4902) {
              console.log('Adding Monad Testnet...');
              await provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: MONAD_CHAIN_ID,
                  chainName: 'Monad Testnet',
                  nativeCurrency: {
                    name: 'Monad',
                    symbol: 'MONAD',
                    decimals: 18
                  },
                  rpcUrls: ['https://testnet-rpc.monad.xyz'],
                  blockExplorerUrls: ['https://testnet.monadscan.com/']
                }]
              });
              console.log('Monad Testnet added');
            }
          }

          // Recreate provider after network switch
          appState.provider = new ethers.providers.Web3Provider(provider);
          appState.signer = appState.provider.getSigner();
        }
      } catch (error) {
        console.error('Network switch error:', error);
        throw new Error('Failed to switch to Monad Testnet');
      }
    }

    // Farcaster Sharing Functions
    function generateShareableContent(type, data = {}) {
      const baseUrl = window.location.origin;
      const tokenBalance = document.getElementById('walletDogDisplay')?.textContent || '0';
      
      const shareTemplates = {
        pet: {
          text: `Just petted the Monad Dog! üêï‚ú®\n\nXP earned: ${appState.xp}\n$DOG Balance: ${tokenBalance}\n\nJoin me on Monad Testnet!`,
          url: `${baseUrl}?ref=pet&xp=${appState.xp}`,
          image: "üêï"
        },
        greet: {
          text: `GM Monad community! ‚òÄÔ∏èüëã\n\nCommunity XP: ${appState.xp}\n$DOG Tokens: ${tokenBalance}\n\nSpread the love on Monad!`,
          url: `${baseUrl}?ref=greet&xp=${appState.xp}`,
          image: "üëã"
        },
        flip: {
          text: `Just flipped a coin on Monad! ü™ô\n\nResult: ${data.result || 'Lucky'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}`,
          url: `${baseUrl}?ref=flip&result=${data.result}&xp=${appState.xp}`,
          image: "ü™ô"
        },
        slots: {
          text: `Just hit the slots on Monad Dog! üé∞\n\nResult: ${data.result || 'Spinning'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}\n\nTry your luck on Monad!`,
          url: `${baseUrl}?ref=slots&xp=${appState.xp}`,
          image: "üé∞"
        },
        wheel: {
          text: `Just spun the Fortune Wheel on Monad Dog! üéØ\n\nWon: ${data.prize || 'Spinning'} (${data.xp || 0} XP)\nTotal XP: ${appState.xp}\n$DOG: ${tokenBalance}\n\nSpin to win on Monad!`,
          url: `${baseUrl}?ref=wheel&xp=${appState.xp}`,
          image: "üéØ"
        },
        claim: {
          text: `Just claimed ${data.amount || 0} $DOG tokens! üí∞\n\nTotal $DOG Balance: ${tokenBalance}\nXP reset - earning again!\n\nEarn XP and claim your $DOG tokens too!`,
          url: `${baseUrl}?ref=claim&tokens=${data.amount}`,
          image: "üí∞"
        },
        invite: {
          text: `Playing Monad Dog - the cutest way to explore Monad Testnet! üêï‚õìÔ∏è\n\n‚ú® Pet dogs, flip coins, say GM/GN\nüéØ Spin the Fortune Wheel\nüé∞ Play Dog Slots\nüí∞ Convert XP to $DOG tokens\nüöÄ Real blockchain interactions\n\nJoin me!`,
          url: `https://monad-snowy.vercel.app?ref=invite&inviter=${appState.address?.slice(0,6)}`,
          image: "üöÄ"
        }
      };
      
      return shareTemplates[type] || shareTemplates.invite;
    }

    function shareOnFarcaster(content) {
      try {
        if (sdk && sdk.actions && sdk.actions.openUrl) {
          // Use Farcaster SDK for sharing
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          sdk.actions.openUrl(shareUrl);
          console.log('üöÄ Shared via Farcaster SDK');
        } else {
          // Fallback to direct URL
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          window.open(shareUrl, '_blank');
          console.log('üöÄ Shared via direct URL');
        }
        
        // Track sharing event
        console.log('üìä Share event tracked:', content);
        
      } catch (error) {
        console.error('‚ùå Share error:', error);
        showError('Failed to open share dialog');
      }
    }

    // Achievement Modal Functions
    window.showAchievementModal = function(achievement) {
      const modal = document.getElementById('achievementModal');
      const icon = document.getElementById('achievementIcon');
      const title = document.getElementById('achievementTitle');
      const description = document.getElementById('achievementDescription');
      
      if (!modal || !icon || !title || !description) {
        console.error('Achievement modal elements not found');
        return;
      }
      
      icon.textContent = achievement.icon || 'üéâ';
      title.textContent = achievement.title || 'Achievement!';
      description.textContent = achievement.description || '';
      
      modal.style.display = 'flex';
      
      // Store current achievement for sharing
      window.currentAchievement = achievement;
      
      // Add escape key listener
      window.achievementEscapeHandler = function(e) {
        if (e.key === 'Escape') {
          closeAchievementModal();
        }
      };
      document.addEventListener('keydown', window.achievementEscapeHandler);
      
      console.log('üéâ Achievement modal shown:', achievement);
    }

    // Individual Share Functions
    window.sharePetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üêï',
        title: 'Dog Lover Achievement!',
        description: `You've been petting dogs and earned ${appState.xp} XP!`,
        type: 'pet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareGreetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üëã',
        title: 'Community Spirit!',
        description: `You've been greeting the community! Spreading love on Monad with ${appState.xp} XP.`,
        type: 'greet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareFlipAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const lastResult = document.getElementById('flip-result').textContent;
      const achievement = {
        icon: 'ü™ô',
        title: 'Lucky Flipper!',
        description: `${lastResult} You've been flipping coins on Monad with ${appState.xp} XP!`,
        type: 'flip',
        data: { result: lastResult }
      };
      
      showAchievementModal(achievement);
    };

    window.shareSlotsAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üé∞',
        title: 'Slots Player!',
        description: `I've been playing Dog Slots on Monad! Current XP: ${appState.xp}. Try your luck!`,
        type: 'slots',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareWheelAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üéØ',
        title: 'Fortune Seeker!',
        description: `I've been spinning the Dog Fortune Wheel on Monad! Current XP: ${appState.xp}. Test your luck!`,
        type: 'wheel',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareAppWithFriends = function() {
      const achievement = {
        icon: 'üöÄ',
        title: 'Invite Friends!',
        description: 'Share Monad Dog with your friends and build the community together!',
        type: 'invite',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    // Start app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }

    console.log('üì± App script loaded');
    }); // End of DOMContentLoaded
  </script>
</body>
</html>
            -button" onclick="sharePetAchievement()">
            üêï Share Pet Achievement
          </button>
        </div>
      </div>

      <!-- Greet Tab -->
      <div id="greet" class="tab-content">
        <h3>Greet Community</h3>
        <p>Say GM or GN to the community!</p>
        <button onclick="sayGM()">‚òÄÔ∏è Good Morning (+5 XP)</button>
        <button onclick="sayGN()">üåô Good Night (+5 XP)</button>
        <div id="greet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareGreetAchievement()">
            üëã Share Community Spirit
          </button>
        </div>
      </div>

      <!-- Flip Tab -->
      <div id="flip" class="tab-content">
        <h3>Flip Coin</h3>
        <div class="coin" id="coin">ü™ô</div>
        <button onclick="flipCoin()">üé≤ Flip Coin (+3 XP)</button>
        <div id="flip-result">Result will appear here</div>
        <div id="flip-status" class="status"></div>
        
        <div class="share-section">
          <button class="share
