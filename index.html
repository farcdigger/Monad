<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monad Dog</title>

<!-- Supabase Client -->
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Farcaster Manifest Link -->
  <link rel="manifest" href="/farcaster.json">
  <link rel="icon" type="image/png" href="https://monad-snowy.vercel.app/.well-known/icon.png">
  
  <!-- Farcaster Meta with Dynamic Content -->
  <meta name="fc:frame" content='{
    "version": "next",
    "imageUrl": "https://monad-snowy.vercel.app/.well-known/share.png",
    "button": {
      "title": "üêï Play Monad Dog",
      "action": {
        "type": "launch_frame",
        "url": "https://monad-snowy.vercel.app",
        "name": "Monad Dog",
        "splashImageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
        "splashBackgroundColor": "#1e003e"
      }
    }
  }' />

  <!-- Open Graph for better sharing -->
  <meta property="og:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta property="og:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta property="og:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />
  <meta property="og:url" content="https://monad-snowy.vercel.app" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta name="twitter:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta name="twitter:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Farcaster Mini App SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/frame-sdk';
    
    // Mini App ready when loaded
    window.addEventListener('load', async () => {
      try {
        await sdk.actions.ready();
        console.log('Farcaster Mini App ready!');
        
        // Make SDK available globally
        window.farcasterSDK = sdk;
      } catch (error) {
        console.log('Not running in Farcaster client:', error);
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .social-link {
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      transition: all 0.3s ease;
      margin-top: 15px;
    }
    
    .social-link:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    
    .social-link svg {
      width: 20px;
      height: 20px;
      fill: white;
    }
    
    .xp {
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 20px;
    }
    
    .wallet-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background: #5855e8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tabs {
      display: flex;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab.active {
      background: #6366f1;
    }
    
    .content {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      min-height: 200px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .dog-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 20px auto;
      display: block;
    }
    
    .coin {
      font-size: 60px;
      margin: 20px;
      transition: transform 0.5s;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }
    
    .status.visible {
      display: block;
    }
    
    .status.success {
      background: rgba(0,255,0,0.2);
      color: #00ff00;
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
      color: #ff6b6b;
    }
    
    .status.pending {
      background: rgba(255,255,0,0.2);
      color: #ffeb3b;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    .loading-subtitle {
      font-size: 14px;
      opacity: 0.7;
      text-align: center;
      max-width: 280px;
      line-height: 1.4;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Skeleton Loading States */
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 16px;
      border-radius: 4px;
      margin: 8px 0;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-button {
      height: 44px;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Hide content initially to prevent layout shift */
    .app-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .app-content.loaded {
      opacity: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    th {
      background: rgba(255,255,255,0.1);
    }
    
    .address {
      font-family: monospace;
      font-size: 12px;
    }

    .badge {
      background: #ff6b9d;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .rank-number {
      font-weight: 600;
      color: #6366f1;
      width: 40px;
    }

    .address-cell {
      font-family: monospace;
      font-size: 12px;
    }

    .share-button {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin: 10px 5px;
      width: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
    }

    .share-section {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .achievement-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    .achievement-content {
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 350px;
      border: 2px solid #6366f1;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 0.6s ease;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      padding: 5px;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .close-modal:hover {
      opacity: 1;
    }

    /* Token Claim Styles */
    .token-stats {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      padding: 8px 16px;
      border-radius: 20px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
      font-size: 14px;
      font-weight: 600;
    }

    .claim-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .claim-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .claim-info-item {
      text-align: center;
    }

    .claim-info-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .claim-info-value {
      font-size: 20px;
      font-weight: 600;
      color: #f59e0b;
    }

    .claim-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 14px 28px;
      border-radius: 12px;
      width: 100%;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .claim-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .claim-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
    }

    .token-balance {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 10px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: 8px;
      font-size: 14px;
    }

    .conversion-rate {
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }

    .claim-history {
      margin-top: 20px;
      font-size: 12px;
      opacity: 0.7;
    }

    .claim-history-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* Slots Machine Styles */
    .slots-machine {
      background: rgba(255,255,255,0.1);
      padding: 25px;
      border-radius: 16px;
      margin: 20px 0;
      border: 2px solid rgba(255,255,255,0.2);
    }

    .slots-display {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 25px 0;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid #6366f1;
    }

    .slot-reel {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }

    .slot-reel.spinning {
      animation: spin-reel 0.1s linear infinite;
    }

    .slot-reel.winning {
      background: rgba(16, 185, 129, 0.3);
      border-color: #10b981;
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
    }

    @keyframes spin-reel {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }

    .slots-info {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .slots-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 12px;
      width: 100%;
      margin: 15px 0;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .slots-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .slots-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
      transform: none;
    }

    .slots-legend {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .symbol-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .symbol-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
    }

    .symbol {
      font-size: 24px;
    }

    .symbol-name {
      font-size: 14px;
      opacity: 0.8;
    }

    .slots-jackpot {
      background: linear-gradient(135deg, #ffd700, #ffed4a);
      color: #1a1a1a;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      text-align: center;
      font-weight: 600;
      animation: jackpot-glow 2s ease-in-out infinite;
    }

    @keyframes jackpot-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
    }
  </style>
</head>
<body>
  <div class="container app-content">
    <div class="header">
      <div class="title">üêï Monad Dog</div>
      <div class="xp">‚ú® Available XP: <span id="xp">0</span></div>
      
      <a href="https://x.com/monaddogg" target="_blank" class="social-link" title="Follow us on Twitter">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
      </a>
    </div>

    <div class="wallet-section">
      <div id="connect-area">
        <button id="connect-btn">üü£ Connect Wallet</button>
      </div>
      <div id="connected-area" style="display: none;">
        <div>üü£ Connected</div>
        <div id="address" class="address"></div>
        <button id="disconnect-btn">Disconnect</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="showTab('pet')">üêï Pet</button>
      <button class="tab" onclick="showTab('greet')">üëã Greet</button>
      <button class="tab" onclick="showTab('flip')">ü™ô Flip</button>
      <button class="tab" onclick="showTab('slots')">üé∞ Slots</button>
      <button class="tab" onclick="showTab('claim')">üí∞ Claim</button>
    </div>

    <div class="content">
      <!-- Pet Tab -->
      <div id="pet" class="tab-content active">
        <h3>Pet the Dog</h3>
        <img id="dog-img" class="dog-image" src="https://placedog.net/400/300?id=7" alt="Dog">
        <button onclick="petDog()">üëã Pet Dog (+10 XP)</button>
        <div id="pet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="sharePetAchievement()">
            üêï Share Pet Achievement
          </button>
        </div>
      </div>

      <!-- Greet Tab -->
      <div id="greet" class="tab-content">
        <h3>Greet Community</h3>
        <p>Say GM or GN to the community!</p>
        <button onclick="sayGM()">‚òÄÔ∏è Good Morning (+5 XP)</button>
        <button onclick="sayGN()">üåô Good Night (+5 XP)</button>
        <div id="greet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareGreetAchievement()">
            üëã Share Community Spirit
          </button>
        </div>
      </div>

      <!-- Flip Tab -->
      <div id="flip" class="tab-content">
        <h3>Flip Coin</h3>
        <div class="coin" id="coin">ü™ô</div>
        <button onclick="flipCoin()">üé≤ Flip Coin (+3 XP)</button>
        <div id="flip-result">Result will appear here</div>
        <div id="flip-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareFlipAchievement()">
            ü™ô Share Lucky Moment
          </button>
        </div>
      </div>

              <!-- Slots Tab -->
      <div id="slots" class="tab-content">
        <h3>üé∞ Dog Slots</h3>
        <p style="margin-bottom: 20px;">Match 4 same dogs or bones to win 5000 XP!</p>
        
        <div class="slots-machine">
          <div class="slots-display">
            <div class="slot-reel" id="reel1">üêï</div>
            <div class="slot-reel" id="reel2">ü¶Æ</div>
            <div class="slot-reel" id="reel3">üê∂</div>
            <div class="slot-reel" id="reel4">ü¶¥</div>
          </div>
          
          <div class="slots-info">
            <div class="cost-info">
              <span style="color: #f59e0b;">üí∞ Pay: 0.1 MONAD = 2 Credits</span>
            </div>
            <div class="prize-info">
              <span style="color: #10b981;">üèÜ 4 Match = 5000 XP</span>
            </div>
          </div>
          
          <button class="slots-button" id="slotsButton" onclick="playSlots()">
            üîí Connect Wallet
          </button>
          
          <div id="slots-status" class="status"></div>
        </div>
        
        <div class="slots-legend">
          <h4 style="margin: 20px 0 10px 0;">How It Works:</h4>
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: left;">
            <p style="margin-bottom: 8px;">üí∞ <strong>Pay 0.1 MONAD</strong> ‚Üí Get 2 game credits</p>
            <p style="margin-bottom: 8px;">üéÆ <strong>Each game</strong> ‚Üí Uses 1 credit</p>
            <p style="margin-bottom: 8px;">‚úÖ <strong>Credits awarded</strong> ‚Üí Only after TX confirms</p>
            <p>üé∞ <strong>Play anytime</strong> ‚Üí Use your available credits</p>
          </div>
          
          <h4 style="margin: 20px 0 10px 0;">Symbols & Prizes:</h4>
          <div class="symbol-grid">
            <div class="symbol-item">
              <span class="symbol">üêï</span>
              <span class="symbol-name">Shiba</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">ü¶Æ</span>
              <span class="symbol-name">Guide Dog</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">üê∂</span>
              <span class="symbol-name">Puppy</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">ü¶¥</span>
              <span class="symbol-name">Bone</span>
            </div>
          </div>
          
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 15px; text-align: left;">
            <p style="margin-bottom: 5px;">üéâ <strong>4 Same:</strong> 5000 XP (JACKPOT!)</p>
            <p style="margin-bottom: 5px;">üèÜ <strong>3 Same:</strong> 500 XP</p>
            <p>‚ú® <strong>2 Same:</strong> 50 XP</p>
          </div>
        </div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareSlotsAchievement()">
            üé∞ Share Slots Win
          </button>
        </div>
      </div>

      <!-- Claim Tab -->
      <div id="claim" class="tab-content">
        <h3>Claim $DOG Tokens</h3>
        <p style="margin-bottom: 20px;">Convert your earned XP to $DOG tokens!</p>
        
        <div class="claim-section">
          <div class="claim-info">
            <div class="claim-info-item">
              <div class="claim-info-label">Available XP</div>
              <div class="claim-info-value" id="claimableXP">0</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">‚Üí</div>
              <div style="font-size: 30px;">üîÑ</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">$DOG Tokens</div>
              <div class="claim-info-value" id="claimableDOG">0</div>
            </div>
          </div>
          
          <button class="claim-button" id="claimButton" onclick="claimTokens()" disabled>
            üí∞ Claim $DOG Tokens
          </button>
          
          <div class="conversion-rate">
            Conversion Rate: 10 XP = 1 $DOG Token
          </div>
          
          <div id="claim-status" class="status"></div>
        </div>
        
        <!-- Token Info -->
        <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 12px;">
          <div style="text-align: center; margin-bottom: 15px;">
            <h4 style="margin-bottom: 10px;">üêï $DOG Token Info</h4>
            <p style="font-size: 12px; opacity: 0.7;">Claim your tokens and they'll be minted directly to your wallet</p>
          </div>
          
          <!-- Wallet DOG Balance Display -->
          <div style="background: linear-gradient(135deg, #f59e0b, #eab308); padding: 20px; border-radius: 12px; text-align: center; margin: 15px 0;">
            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Your Wallet Balance</div>
            <div style="font-size: 32px; font-weight: 700;">
              <span id="walletDogDisplay">0</span> $DOG
            </div>
            <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">ü™ô Monad Testnet</div>
          </div>
          
          <div style="margin-top: 15px; text-align: center;">
            <a href="https://testnet.monadscan.com/address/0x1f6649d028c4c146c050a9b224115a01c92a02f3" 
               target="_blank" 
               class="share-button" 
               style="background: rgba(255,255,255,0.1); font-size: 12px; padding: 8px 16px;">
              üîç View Token Contract
            </a>
          </div>
        </div>
      </div>
    </div>

    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Monad Dog...</div>
      <div class="loading-subtitle">Starting Monad Dog...<br>üöÄ Initializing blockchain connection</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loadingProgressBar"></div>
      </div>
    </div>

    <!-- Achievement Modal -->
    <div id="achievementModal" class="achievement-modal" onclick="if(event.target === this) closeAchievementModal()">
      <div class="achievement-content">
        <button class="close-modal" onclick="closeAchievementModal()">√ó</button>
        <div id="achievementIcon" class="achievement-icon">üéâ</div>
        <h3 id="achievementTitle">Achievement Unlocked!</h3>
        <p id="achievementDescription">You did something awesome!</p>
        <div style="margin-top: 20px;">
          <button class="share-button" onclick="shareCurrentAchievement()">
            üì¢ Share on Farcaster
          </button>
          <button class="share-button" onclick="closeAchievementModal()" style="background: rgba(255,255,255,0.2);">
            ‚ú® Continue Playing
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Wait for Supabase to load
    window.addEventListener('DOMContentLoaded', function() {
      // Supabase Configuration
      const SUPABASE_URL = 'https://uhqszfoekqrjtybrwqzt.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVocXN6Zm9la3FyanR5YnJ3cXp0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4MDMxNTAsImV4cCI6MjA2NjM3OTE1MH0.gGch8B6AlvGrZTDVjfd0xidVnh_Dsua4qRxbaixBqM0';
      
      // Initialize Supabase
      let supabaseClient;
      if (window.supabase) {
        const { createClient } = window.supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ Supabase initialized');
      } else {
        console.error('‚ùå Supabase not loaded');
      }
    
      // Initialize modal close functions globally
      window.closeAchievementModal = function() {
        const modal = document.getElementById('achievementModal');
        if (modal) {
          modal.style.display = 'none';
        }
        window.currentAchievement = null;
        
        // Remove escape key listener
        if (window.achievementEscapeHandler) {
          document.removeEventListener('keydown', window.achievementEscapeHandler);
        }
        
        console.log('Modal closed');
      }
      
      window.shareCurrentAchievement = function() {
        if (window.currentAchievement) {
          try {
            const content = generateShareableContent(window.currentAchievement.type, window.currentAchievement.data);
            shareOnFarcaster(content);
            
            // Close modal after sharing
            setTimeout(() => {
              closeAchievementModal();
            }, 500);
          } catch (error) {
            console.error('Error sharing achievement:', error);
            closeAchievementModal();
          }
        }
      }
      
      console.log('üöÄ Starting app...');

    // Enhanced Loading Management
    let loadingProgress = 0;
    let isAppReady = false;
    let activeTab = 'pet';

    function updateLoadingProgress(progress, message) {
      const progressBar = document.getElementById('loadingProgressBar');
      const subtitle = document.querySelector('.loading-subtitle');
      
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      if (subtitle && message) {
        subtitle.innerHTML = message;
      }
      
      loadingProgress = progress;
      console.log(`üìä Loading progress: ${progress}% - ${message}`);
    }

    function showLoadingState() {
      document.getElementById('loading').style.display = 'flex';
      document.querySelector('.app-content').classList.remove('loaded');
      updateLoadingProgress(0, 'Starting Monad Dog...<br>üöÄ Initializing blockchain connection');
    }

    function hideLoadingState() {
      // Don't hide immediately - show completion
      updateLoadingProgress(100, 'Ready to play! üéâ<br>Welcome to Monad Dog!');
      
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.querySelector('.app-content').classList.add('loaded');
        isAppReady = true;
        
        // Call Farcaster ready action
        if (sdk && sdk.actions && sdk.actions.ready) {
          sdk.actions.ready({
            disableNativeGestures: false // Allow native gestures for better UX
          }).then(() => {
            console.log('‚úÖ Farcaster SDK ready called successfully');
          }).catch(error => {
            console.log('‚ö†Ô∏è Farcaster SDK ready failed:', error);
          });
        }
        
        console.log('üéâ App fully loaded and ready');
      }, 500);
    }

    // Contract addresses and ABIs - SECURE VERSION
    const CONTRACTS = {
      PET: "0xc53abe4c593b9440407f8ac1b346f3f999e6d8ed",
      GREET: "0xbc8b78f3e2348d4b5e0390fe700ce54b59931da4",
      FLIP: "0xc5b2280d1e2f155f9a2be2af7e78190658874106",
      SLOTS: "0xbc4878841020d79cbd5b0c7b317385c8664ecb34",
      XP_MANAGER: "0x0000000000000000000000000000000000000000", // TODO: Deploy XP Manager
      DOG_TOKEN: "0x1f6649d028c4c146c050a9b224115a01c92a02f3"
    };

    const ABIS = {
      PET: ["function pet() public"],
      GREET: ["function gm() public", "function gn() public"],
      FLIP: ["function flip() public"],
      SLOTS: [
        "function buyCredits() external payable", // ‚úÖ PAYABLE EKLENDƒ∞
        "function playSlots() external returns (uint8[4])",
        "function getCredits(address player) external view returns (uint256)",
        "function getGameStats() external view returns (uint256, uint256, uint256)",
        "event CreditsPurchased(address indexed player, uint256 credits, uint256 cost)",
        "event GamePlayed(address indexed player, uint8[4] results, uint256 creditsRemaining)",
        "event Jackpot(address indexed player, uint8 symbol, uint256 prize)"
      ],
      XP_MANAGER: [
        "function getAvailableXP(address user) external view returns (uint256)",
        "function getTotalEarnedXP(address user) external view returns (uint256)",
        "function getTotalClaimedXP(address user) external view returns (uint256)",
        "function getUserStats(address user) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256)",
        "event XPEarned(address indexed user, uint256 amount, string activity)",
        "event XPSpent(address indexed user, uint256 amount, string purpose)"
      ],
      DOG_TOKEN: [
        "function claimTokens(uint256 xpAmount) external",
        "function balanceOf(address account) public view returns (uint256)",
        "function getClaimableTokens(address user) external view returns (uint256)",
        "function getUserTotalClaimed(address user) external view returns (uint256)",
        "function getTokenStats(address user) external view returns (uint256, uint256, uint256, uint256, uint256)",
        "event TokensClaimed(address indexed user, uint256 xpSpent, uint256 tokensReceived)"
      ]
    };

    // XP to DOG token conversion rate
    const XP_TO_DOG_RATE = 10; // 10 XP = 1 DOG token

    // Global state 
    let appState = {
      connected: false,
      address: null,
      xp: 0, // Available XP (can be used for claiming)
      slotsCredits: 0, // Available slots game credits
      provider: null,
      signer: null,
      isTransactionPending: false
    };

    // Initialize SDK
    let sdk = null;
    
    // ‚úÖ SECURE XP MANAGEMENT - Contract-based only
    async function getWalletXP(address) {
      if (!address || !appState.provider) return 0;
      
      try {
        // ‚úÖ SECURE: Only get XP from XP Manager contract
        const xpManager = new ethers.Contract(
          CONTRACTS.XP_MANAGER,
          ABIS.XP_MANAGER,
          appState.provider
        );
        
        const availableXP = await xpManager.getAvailableXP(address);
        return availableXP.toNumber();
      } catch (e) {
        console.error('Error fetching XP from XP Manager:', e);
        return 0; // ‚úÖ SECURE: No fallback to localStorage
      }
    }

    async function saveWalletXP(address, xp) {
      // ‚úÖ SECURE: XP is only managed by smart contracts
      // This function is now deprecated - XP is managed on-chain
      console.log('XP management is now handled by smart contracts only');
    }

    // ‚úÖ SLOTS CREDITS MANAGEMENT - Updated with real contract integration
    async function getSlotsCredits(address) {
      if (!address || !appState.provider) return 0;
      
      try {
        // Get credits from smart contract
        const slotsContract = new ethers.Contract(
          CONTRACTS.SLOTS,
          ABIS.SLOTS,
          appState.provider
        );
        
        const credits = await slotsContract.getCredits(address);
        return credits.toNumber();
      } catch (e) {
        console.error('Error fetching slots credits from contract:', e);
        // Fallback to localStorage
        return parseInt(localStorage.getItem(`slots_credits_${address.toLowerCase()}`) || '0');
      }
    }

    async function saveSlotsCredits(address, credits) {
      if (!address) return;
      
      // Save to localStorage for immediate display
      localStorage.setItem(`slots_credits_${address.toLowerCase()}`, credits.toString());
      
      // Note: Actual credits are managed by smart contract
      // This is just for UI consistency
    }

    async function updateSlotsCreditsDisplay() {
      if (appState.connected && appState.address) {
        const credits = await getSlotsCredits(appState.address);
        appState.slotsCredits = credits;
        
        // Update slots button text
        updateSlotsButton();
        
        console.log(`üé∞ Slots Credits - Available: ${credits}`);
      } else {
        appState.slotsCredits = 0;
        updateSlotsButton();
      }
    }

    function updateSlotsButton() {
      const slotsButton = document.getElementById('slotsButton');
      if (!slotsButton) return;
      
      if (appState.slotsCredits > 0) {
        slotsButton.textContent = `üé∞ Play Slots (${appState.slotsCredits} credits)`;
        slotsButton.disabled = false;
      } else if (appState.connected) {
        slotsButton.textContent = `üí∞ Buy 2 Credits (0.1 MONAD)`;
        slotsButton.disabled = false;
      } else {
        slotsButton.textContent = `üîí Connect Wallet`;
        slotsButton.disabled = true;
      }
    }

    async function updateXPDisplay() {
      if (appState.connected && appState.address) {
        // Show current value immediately
        const currentDisplay = document.getElementById('xp').textContent;
        
        // Get XP (with timeout to prevent hanging)
        const xpPromise = getWalletXP(appState.address);
        const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(parseInt(currentDisplay) || 0), 1000));
        
        const walletXP = await Promise.race([xpPromise, timeoutPromise]);
        
        document.getElementById('xp').textContent = walletXP;
        appState.xp = walletXP;
        
        // Also update slots credits
        await updateSlotsCreditsDisplay();
        
        console.log(`üìä XP Display - Available: ${walletXP}`);
        
        // Update claim UI non-blocking
        if (activeTab === 'claim') {
          requestAnimationFrame(() => updateClaimUI());
        }
      } else {
        document.getElementById('xp').textContent = '0';
        appState.xp = 0;
        appState.slotsCredits = 0;
        updateClaimUI();
        updateSlotsButton();
      }
    }

    // Update claim UI based on current XP
    async function updateClaimUI() {
      const claimableXP = appState.xp || 0;
      const claimableDOG = Math.floor(claimableXP / XP_TO_DOG_RATE);
      
      document.getElementById('claimableXP').textContent = claimableXP;
      document.getElementById('claimableDOG').textContent = claimableDOG;
      
      const claimButton = document.getElementById('claimButton');
      if (claimableXP >= XP_TO_DOG_RATE && appState.connected) {
        claimButton.disabled = false;
        claimButton.textContent = `üí∞ Claim ${claimableDOG} $DOG Tokens`;
      } else {
        claimButton.disabled = true;
        if (!appState.connected) {
          claimButton.textContent = 'üîí Connect Wallet First';
        } else if (claimableXP < XP_TO_DOG_RATE) {
          claimButton.textContent = `üìà Need ${XP_TO_DOG_RATE - claimableXP} more XP`;
        }
      }
      
      // Update token balance
      await updateTokenBalance();
    }

    // Update token balance display
    async function updateTokenBalance() {
      if (!appState.connected || !appState.provider || !appState.address) {
        console.log('‚ùå Not connected, cannot fetch balance');
        document.getElementById('walletDogDisplay').textContent = '0';
        return;
      }
      
      console.log('üîÑ Fetching DOG balance for:', appState.address);
      
      try {
        // Check if we're using Farcaster wallet
        const isFarcasterWallet = sdk && sdk.wallet && sdk.wallet.ethProvider;
        
        if (isFarcasterWallet) {
          console.log('üü£ Using Farcaster wallet - trying direct RPC call');
          
          try {
            // Encode the balanceOf function call
            const iface = new ethers.utils.Interface([
              "function balanceOf(address account) public view returns (uint256)"
            ]);
            const data = iface.encodeFunctionData("balanceOf", [appState.address]);
            
            // Make the call using the provider's send method
            const result = await appState.provider.send("eth_call", [{
              to: CONTRACTS.DOG_TOKEN,
              data: data
            }, "latest"]);
            
            console.log('Raw result:', result);
            
            if (result && result !== '0x') {
              const balance = ethers.BigNumber.from(result);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`‚úÖ DOG Balance (Farcaster): ${displayBalance}`);
            } else {
              console.log('No balance or contract not found');
              document.getElementById('walletDogDisplay').textContent = '0';
            }
            
          } catch (callError) {
            console.error('Direct eth_call failed:', callError);
            
            // Fallback: Try using a public RPC endpoint
            console.log('Trying fallback RPC...');
            try {
              const fallbackProvider = new ethers.providers.JsonRpcProvider('https://testnet-rpc.monad.xyz');
              const dogTokenContract = new ethers.Contract(
                CONTRACTS.DOG_TOKEN,
                ["function balanceOf(address) view returns (uint256)"],
                fallbackProvider
              );
              
              const balance = await dogTokenContract.balanceOf(appState.address);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`‚úÖ DOG Balance (Fallback RPC): ${displayBalance}`);
              
            } catch (fallbackError) {
              console.error('Fallback RPC also failed:', fallbackError);
              document.getElementById('walletDogDisplay').textContent = '0';
            }
          }
          
        } else {
          // Regular wallet (MetaMask, etc.)
          console.log('ü¶ä Using regular wallet provider');
          
          const dogTokenContract = new ethers.Contract(
            CONTRACTS.DOG_TOKEN,
            ["function balanceOf(address) view returns (uint256)"],
            appState.provider
          );
          
          const balance = await dogTokenContract.balanceOf(appState.address);
          const formattedBalance = ethers.utils.formatUnits(balance, 18);
          const numBalance = parseFloat(formattedBalance);
          const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                               numBalance > 0 ? numBalance.toFixed(6) : '0';
          
          document.getElementById('walletDogDisplay').textContent = displayBalance;
          console.log(`‚úÖ DOG Balance: ${displayBalance}`);
        }
        
      } catch (error) {
        console.error('‚ùå Error fetching token balance:', error);
        
        // Last resort: Use localStorage cache if available
        const cachedBalance = localStorage.getItem(`dog_balance_${appState.address.toLowerCase()}`);
        if (cachedBalance) {
          document.getElementById('walletDogDisplay').textContent = cachedBalance;
          console.log(`üì¶ Using cached balance: ${cachedBalance}`);
        } else {
          document.getElementById('walletDogDisplay').textContent = '0';
        }
      }
    }

    // ‚úÖ FIXED CLAIM FUNCTION - XP resets after user confirms transaction + Button cooldown
    window.claimTokens = async function() {
      if (!appState.connected || !appState.signer) {
        showError('Please connect your wallet first');
        return;
      }
      
      const availableXP = appState.xp;
      const claimableDOG = Math.floor(availableXP / XP_TO_DOG_RATE);
      
      if (availableXP < XP_TO_DOG_RATE) {
        showError(`Need at least ${XP_TO_DOG_RATE} XP to claim tokens`);
        return;
      }
      
      const claimButton = document.getElementById('claimButton');
      
      try {
        console.log('üí∞ Starting token claim...');
        
        // ‚úÖ Disable button immediately for 30 seconds
        claimButton.disabled = true;
        
        // Start countdown
        let countdown = 30;
        const originalText = claimButton.textContent;
        
        const countdownInterval = setInterval(() => {
          countdown--;
          claimButton.textContent = `‚è≥ Please wait ${countdown}s...`;
          
          if (countdown <= 0) {
            clearInterval(countdownInterval);
            // Re-enable button and update text after countdown
            updateClaimUI();
          }
        }, 1000);
        
        showStatus('claim-status', 'üîê Please confirm transaction in your wallet...', 'pending');
        
        // Ensure correct network
        await ensureMonadNetwork();
        
        // Call the actual DOG token contract
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          ABIS.DOG_TOKEN,
          appState.signer
        );
        
        // Calculate XP to claim (must be multiple of 10)
        const xpToClaim = claimableDOG * XP_TO_DOG_RATE;
        
        console.log(`Claiming ${xpToClaim} XP for ${claimableDOG} DOG tokens`);
        
        // Execute claim transaction with proper gas limit
        const tx = await dogTokenContract.claim(xpToClaim, {
          gasLimit: 100000
        });
        
        // ‚úÖ USER CONFIRMED TRANSACTION - NOW RESET XP IMMEDIATELY
        console.log('üéØ Transaction confirmed by user - resetting XP to 0');
        
        // Reset XP to 0 in state and display immediately
        appState.xp = 0;
        document.getElementById('xp').textContent = '0';
        
        // ‚úÖ Save XP as 0 to Supabase immediately
        await saveWalletXP(appState.address, 0);
        
        // Update claim UI immediately
        await updateClaimUI();
        
        showStatus('claim-status', `üì° Transaction sent: ${tx.hash.slice(0,10)}... XP reset to 0`, 'pending');
        console.log('Transaction hash:', tx.hash);
        console.log('‚úÖ XP successfully reset to 0 - user can continue earning');
        
        // Wait for confirmation and update balance
        setTimeout(async () => {
          try {
            // Try to get updated balance with multiple retries
            const updateBalanceWithRetry = async (retries = 3) => {
              for (let i = 0; i < retries; i++) {
                try {
                  await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                  
                  const newBalance = await dogTokenContract.balanceOf(appState.address);
                  const decimals = await dogTokenContract.decimals();
                  const formattedBalance = ethers.utils.formatUnits(newBalance, decimals);
                  
                  const numBalance = parseFloat(formattedBalance);
                  const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : numBalance.toFixed(6);
                  
                  document.getElementById('walletDogDisplay').textContent = displayBalance;
                  
                  // Cache the balance
                  localStorage.setItem(`dog_balance_${appState.address.toLowerCase()}`, displayBalance);
                  
                  console.log(`‚úÖ Balance updated after claim (attempt ${i + 1}): ${displayBalance} DOG`);
                  break;
                } catch (e) {
                  console.log(`Balance update attempt ${i + 1} failed, retrying...`);
                }
              }
            };
            
            updateBalanceWithRetry();
            
            showStatus('claim-status', `‚úÖ Successfully claimed ${claimableDOG} $DOG tokens! XP reset - start earning again!`, 'success');
            
            // Show achievement
            showAchievementModal({
              icon: 'üí∞',
              title: 'Tokens Claimed!',
              description: `You've successfully claimed ${claimableDOG} $DOG tokens! Your XP has been reset - start earning again!`,
              type: 'claim',
              data: { amount: claimableDOG }
            });
            
            setTimeout(() => hideStatus('claim-status'), 8000);
            
          } catch (e) {
            console.log('Post-claim update error:', e);
            showStatus('claim-status', `‚úÖ Claim transaction sent! Tokens will arrive soon. XP reset successfully.`, 'success');
            setTimeout(() => hideStatus('claim-status'), 8000);
          }
        }, 5000);
        
      } catch (error) {
        console.error('‚ùå Claim error:', error);
        
        let errorMsg = 'Failed to claim tokens';
        
        if (error.message.includes('user rejected')) {
          errorMsg = 'Transaction cancelled - XP not affected';
          // Don't reset XP if user cancelled
          console.log('üö´ Transaction cancelled - XP remains unchanged');
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient gas funds';
        } else if (error.message.includes('XP already claimed')) {
          errorMsg = 'This XP has already been claimed';
          // Reset XP if already claimed on contract
          appState.xp = 0;
          await saveWalletXP(appState.address, 0);
          await updateXPDisplay();
        } else if (error.message.includes('Invalid XP amount')) {
          errorMsg = 'Invalid XP amount. Must be multiple of 10';
        }
        
        showStatus('claim-status', errorMsg, 'error');
        setTimeout(() => hideStatus('claim-status'), 5000);
      }
    };

    async function initializeAppWithProgress() {
      try {
        showLoadingState();
        
        // Step 1: Initialize SDK
        updateLoadingProgress(20, 'Loading Farcaster SDK...<br>üîó Connecting to Frame environment');
        
        try {
          const module = await import('https://esm.sh/@farcaster/frame-sdk');
          sdk = module.sdk;
          console.log('SDK loaded:', !!sdk);
          
          if (sdk) {
            updateLoadingProgress(40, 'Farcaster SDK loaded! ‚úÖ<br>üì± Setting up Mini App environment');
            await sdk.actions.ready();
            console.log('SDK ready');
          }
        } catch (e) {
          console.log('SDK not available:', e.message);
          updateLoadingProgress(40, 'Running in standalone mode<br>üåê Browser environment detected');
        }

        // Step 2: Setup game functions
        updateLoadingProgress(60, 'Setting up game functions...<br>üéÆ Preparing blockchain interactions');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        setupEventListeners();
        setupGameFunctions();
        
        // Step 3: Initialize app
        updateLoadingProgress(80, 'Initializing app...<br>üéÆ Setting up game');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Step 4: Finalize
        updateLoadingProgress(95, 'Almost ready...<br>‚ú® Final preparations');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        hideLoadingState();
        console.log('‚úÖ App initialized successfully with progress tracking');
        
      } catch (error) {
        console.error('‚ùå Init error:', error);
        updateLoadingProgress(100, 'Error occurred, but app will continue<br>‚ö†Ô∏è Some features may be limited');
        
        setTimeout(() => {
          hideLoadingState();
        }, 1000);
      }
    }

    async function initApp() {
      await initializeAppWithProgress();
    }

    function setupEventListeners() {
      document.getElementById('connect-btn').onclick = connectWallet;
      document.getElementById('disconnect-btn').onclick = disconnect;
    }

    // Disable all action buttons during transaction
    function disableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = true;
          button.dataset.originalText = button.textContent;
        }
      });
      
      appState.isTransactionPending = true;
    }

    // Enable all action buttons after transaction
    function enableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = false;
          if (button.dataset.originalText) {
            button.textContent = button.dataset.originalText;
            delete button.dataset.originalText;
          }
        }
      });
      
      appState.isTransactionPending = false;
      
      // Update claim button state
      if (activeTab === 'claim') {
        updateClaimUI();
      }
    }

    function setupGameFunctions() {
      // Define all game functions globally
      window.petDog = async function() {
        console.log('üêï Pet Dog clicked!');
        
        if (!appState.connected) {
          console.log('‚ùå Wallet not connected');
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        console.log('‚úÖ Wallet connected, starting pet transaction');
        
        // Change dog image
        document.getElementById('dog-img').src = `https://placedog.net/400/300?id=${Math.floor(Math.random() * 50) + 1}`;
        
        // Execute real blockchain transaction
        await executeTransaction(
          CONTRACTS.PET,
          ABIS.PET,
          'pet',
          'pet-status',
          'üêï Dog petted successfully! +10 XP',
          10
        );
      };

      window.sayGM = async function() {
        console.log('‚òÄÔ∏è Say GM clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gm',
          'greet-status',
          '‚òÄÔ∏è Good Morning sent! +5 XP',
          5
        );
      };

      window.sayGN = async function() {
        console.log('üåô Say GN clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gn',
          'greet-status',
          'üåô Good Night sent! +5 XP',
          5
        );
      };

      window.flipCoin = async function() {
        console.log('ü™ô Flip Coin clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const coin = document.getElementById('coin');
        const result = document.getElementById('flip-result');
        
        // Start visual animation
        result.textContent = 'Flipping...';
        let rotation = 0;
        const interval = setInterval(() => {
          rotation += 180;
          coin.style.transform = `rotateY(${rotation}deg)`;
        }, 100);
        
        // Execute real transaction
        await executeTransaction(
          CONTRACTS.FLIP,
          ABIS.FLIP,
          'flip',
          'flip-status',
          'ü™ô Coin flipped! +3 XP',
          3
        );
        
        // Stop animation after transaction starts
        setTimeout(() => {
          clearInterval(interval);
          const finalResult = Math.random() < 0.5 ? 'Heads' : 'Tails';
          coin.style.transform = `rotateY(${finalResult === 'Heads' ? 0 : 180}deg)`;
          result.textContent = `Result: ${finalResult}!`;
        }, 3000);
      };

      // ‚úÖ SLOTS GAME FUNCTION - REDESIGNED WITH CREDITS SYSTEM
      window.playSlots = async function() {
        console.log('üé∞ Play Slots clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        // Check if user has credits or needs to buy
        if (appState.slotsCredits > 0) {
          // USE EXISTING CREDIT
          await playSlotGame();
        } else {
          // BUY CREDITS WITH 0.1 MONAD
          await buySlotCredits();
        }
      };

      // Buy slot credits with 0.1 MONAD payment - DEBUG VERSION
      async function buySlotCredits() {
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        try {
          // Disable button immediately
          slotsButton.disabled = true;
          slotsButton.textContent = 'üí∞ Buying Credits...';
          
          showStatus('slots-status', 'üîê Please confirm payment of 0.1 MONAD for 2 game credits...', 'pending');
          
          // Ensure correct network
          await ensureMonadNetwork();
          
          console.log('üîç DEBUG: Contracts address:', CONTRACTS.SLOTS);
          console.log('üîç DEBUG: Signer:', appState.signer);
          
          // ‚úÖ TRY DIFFERENT APPROACH - Direct transaction
          try {
            // Method 1: Direct transaction to contract
            const tx = await appState.signer.sendTransaction({
              to: CONTRACTS.SLOTS,
              value: ethers.utils.parseEther("0.1"),
              data: "0x6a28f000", // buyCredits() function selector
              gasLimit: 150000
            });
            
            console.log('‚úÖ Direct transaction sent:', tx.hash);
            showStatus('slots-status', `üì° Payment sent: ${tx.hash.slice(0,10)}... Waiting for confirmation...`, 'pending');
            
            // Wait for confirmation
            setTimeout(async () => {
              try {
                // Get credits from contract
                const slotsContract = new ethers.Contract(
                  CONTRACTS.SLOTS, 
                  ["function getCredits(address) view returns (uint256)"], 
                  appState.provider
                );
                
                const credits = await slotsContract.getCredits(appState.address);
                appState.slotsCredits = credits.toNumber();
                
                await saveSlotsCredits(appState.address, appState.slotsCredits);
                updateSlotsButton();
                
                showStatus('slots-status', `‚úÖ Payment confirmed! You have ${appState.slotsCredits} game credits!`, 'success');
                setTimeout(() => hideStatus('slots-status'), 3000);
                
              } catch (e) {
                console.error('Error getting credits:', e);
                // Assume 2 credits
                appState.slotsCredits += 2;
                await saveSlotsCredits(appState.address, appState.slotsCredits);
                updateSlotsButton();
                
                showStatus('slots-status', '‚úÖ Payment confirmed! Credits should be available.', 'success');
                setTimeout(() => hideStatus('slots-status'), 3000);
              }
            }, 5000);
            
          } catch (directError) {
            console.error('Direct transaction failed:', directError);
            
            // Method 2: Try with different ABI
            const altABI = [
              "function buyCredits() payable",
              "function purchaseCredits() payable", 
              "function buy() payable"
            ];
            
            for (let abi of altABI) {
              try {
                console.log(`üîÑ Trying ABI: ${abi}`);
                const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, [abi], appState.signer);
                const functionName = abi.split('(')[0].split(' ')[1];
                
                const tx = await slotsContract[functionName]({
                  value: ethers.utils.parseEther("0.1"),
                  gasLimit: 150000
                });
                
                console.log(`‚úÖ Success with ${functionName}:`, tx.hash);
                showStatus('slots-status', `üì° Payment sent: ${tx.hash.slice(0,10)}...`, 'pending');
                
                setTimeout(async () => {
                  appState.slotsCredits += 2;
                  await saveSlotsCredits(appState.address, appState.slotsCredits);
                  updateSlotsButton();
                  showStatus('slots-status', '‚úÖ Payment confirmed!', 'success');
                  setTimeout(() => hideStatus('slots-status'), 3000);
                }, 5000);
                
                return; // Success, exit
                
              } catch (abiError) {
                console.log(`‚ùå ${abi} failed:`, abiError.message);
              }
            }
            
            throw new Error('All methods failed');
          }
          
        } catch (error) {
          console.error('‚ùå All payment methods failed:', error);
          
          slotsButton.disabled = false;
          slotsButton.textContent = originalText;
          
          let errorMsg = 'Payment failed - check contract';
          if (error.message.includes('user rejected')) {
            errorMsg = 'Payment cancelled';
          } else if (error.message.includes('insufficient funds')) {
            errorMsg = 'Insufficient MONAD balance';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Play the actual slot game using 1 credit - REAL CONTRACT VERSION
      async function playSlotGame() {
        if (appState.slotsCredits <= 0) {
          showError('No game credits available');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        
        try {
          // Disable button during game
          slotsButton.disabled = true;
          slotsButton.textContent = 'üé∞ Playing...';
          
          console.log(`üéÆ Playing slots with contract, current credits: ${appState.slotsCredits}`);
          showStatus('slots-status', 'üé∞ Spinning the reels...', 'pending');
          
          // ‚úÖ REAL CONTRACT CALL
          const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, ABIS.SLOTS, appState.signer);
          
          // Play slots on contract (uses 1 credit automatically)
          const tx = await slotsContract.playSlots({
            gasLimit: 150000
          });
          
          console.log('‚úÖ Slots game transaction sent:', tx.hash);
          
          // Start visual animation while waiting for result
          const symbols = ['üêï', 'ü¶Æ', 'üê∂', 'ü¶¥'];
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          
          // Spinning animation
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.add('spinning');
          });
          
          let spinDuration = 4000; // 4 seconds of spinning
          
          const spinInterval = setInterval(() => {
            reels.forEach(reelId => {
              const reel = document.getElementById(reelId);
              reel.textContent = symbols[Math.floor(Math.random() * symbols.length)];
            });
          }, 100);
          
          // Wait for transaction and get results
          setTimeout(async () => {
            clearInterval(spinInterval);
            
            try {
              // Get transaction receipt to see events
              const receipt = await appState.provider.getTransactionReceipt(tx.hash);
              
              // Parse game results from events (simplified - in real implementation you'd parse the event)
              // For now, generate results based on transaction hash for deterministic results
              const results = [];
              const txHash = tx.hash;
              for (let i = 0; i < 4; i++) {
                const byte = parseInt(txHash.slice(2 + i * 2, 4 + i * 2), 16);
                results.push(symbols[byte % 4]);
              }
              
              // Display final results
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Update credits from contract
              const newCredits = await slotsContract.getCredits(appState.address);
              appState.slotsCredits = newCredits.toNumber();
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              console.log(`üéÆ Game completed, remaining credits: ${appState.slotsCredits}`);
              
              // Check for winning combinations and award XP
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
              
            } catch (e) {
              console.error('Error processing game result:', e);
              
              // Fallback: Generate random results and update credits
              const results = [];
              for (let i = 0; i < 4; i++) {
                results.push(symbols[Math.floor(Math.random() * symbols.length)]);
              }
              
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Assume 1 credit was used
              appState.slotsCredits = Math.max(0, appState.slotsCredits - 1);
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
            }
          }, spinDuration);
          
        } catch (error) {
          console.error('‚ùå Game error:', error);
          
          // Stop spinning animation
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.remove('spinning');
          });
          
          updateSlotsButton();
          
          let errorMsg = 'Game failed';
          if (error.message.includes('No credits available')) {
            errorMsg = 'No credits available';
          } else if (error.message.includes('user rejected')) {
            errorMsg = 'Game cancelled';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Check slots winning combinations
      function checkSlotsWin(results) {
        console.log('üé∞ Slots results:', results);
        
        // Count occurrences of each symbol
        const symbolCounts = {};
        results.forEach(symbol => {
          symbolCounts[symbol] = (symbolCounts[symbol] || 0) + 1;
        });
        
        // Check for 4 of a kind (jackpot)
        const maxCount = Math.max(...Object.values(symbolCounts));
        
        if (maxCount === 4) {
          // JACKPOT! 4 of a kind
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 4);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 5000 XP
          addXP(5000);
          
          showStatus('slots-status', `üéâ JACKPOT! 4x ${winningSymbol} = +5000 XP!`, 'success');
          
          // Show jackpot achievement
          setTimeout(() => {
            showAchievementModal({
              icon: 'üé∞',
              title: 'JACKPOT WINNER!',
              description: `Amazing! You got 4x ${winningSymbol} and won 5000 XP! You're incredibly lucky!`,
              type: 'slots',
              data: { 
                symbol: winningSymbol, 
                count: 4, 
                xp: 5000,
                result: results.join('')
              }
            });
          }, 1000);
          
        } else if (maxCount === 3) {
          // 3 of a kind - smaller win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 3);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 500 XP for 3 of a kind
          addXP(500);
          
          showStatus('slots-status', `üèÜ 3x ${winningSymbol} = +500 XP!`, 'success');
          
        } else if (maxCount === 2) {
          // 2 of a kind - small win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 2);
          
          // Award 50 XP for 2 of a kind
          addXP(50);
          
          showStatus('slots-status', `‚ú® 2x ${winningSymbol} = +50 XP!`, 'success');
          
        } else {
          // No win
          showStatus('slots-status', 'üòî No match this time. Try again!', 'error');
        }
        
        // Clear status and winning highlights after delay
        setTimeout(() => {
          hideStatus('slots-status');
          document.querySelectorAll('.slot-reel').forEach(reel => {
            reel.classList.remove('winning');
          });
        }, 5000);
      }

      // Reset slots display
      function resetSlotsDisplay() {
        const symbols = ['üêï', 'ü¶Æ', 'üê∂', 'ü¶¥'];
        const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
        
        reels.forEach((reelId, index) => {
          const reel = document.getElementById(reelId);
          reel.textContent = symbols[index];
          reel.classList.remove('spinning', 'winning');
        });
      }

      window.showTab = function(tabName) {
        console.log('üìë Switching to tab:', tabName);
        activeTab = tabName;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
        
        // Update claim UI when switching to claim tab
        if (tabName === 'claim') {
          updateClaimUI();
          // Update balance with delay for better reliability
          setTimeout(() => {
            updateTokenBalance();
          }, 500);
        }
        
        // Update slots when switching to slots tab
        if (tabName === 'slots') {
          resetSlotsDisplay();
          updateSlotsButton();
        }
      };
      
      console.log('üéÆ Game functions setup complete');
    }

    async function connectWallet() {
      try {
        console.log('Connecting wallet...');
        
        // Show loading state
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = 'üîÑ Connecting...';
        connectBtn.disabled = true;
        
        let provider;
        
        if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
          console.log('Using Farcaster wallet');
          provider = sdk.wallet.ethProvider;
        } else if (window.ethereum) {
          console.log('Using browser wallet');
          provider = window.ethereum;
        } else {
          throw new Error('No wallet available');
        }

        // Request accounts with timeout
        const accountsPromise = provider.request({
          method: 'eth_requestAccounts'
        });
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), 10000)
        );
        
        const accounts = await Promise.race([accountsPromise, timeoutPromise]);

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }

        console.log('‚úÖ Connected:', accounts[0]);

        // Setup ethers
        appState.provider = new ethers.providers.Web3Provider(provider);
        appState.signer = appState.provider.getSigner();
        appState.address = accounts[0];
        appState.connected = true;

        // Update UI and load wallet-specific data
        updateWalletUI();
        
        // Load data asynchronously
        updateXPDisplay().catch(console.error);
        
        // Ensure network is correct before fetching balance
        await ensureMonadNetwork();
        
        // Update token balance with multiple retries
        const fetchBalance = async () => {
          for (let i = 0; i < 3; i++) {
            try {
              await updateTokenBalance();
              break;
            } catch (e) {
              console.log(`Balance fetch attempt ${i + 1} failed, retrying...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          }
        };
        
        fetchBalance();

      } catch (error) {
        console.error('Connection error:', error);
        showError(error.message);
        
        // Reset button
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = 'üü£ Connect Wallet';
        connectBtn.disabled = false;
      }
    }

    async function disconnect() {
      appState = {
        connected: false,
        address: null,
        xp: 0,
        slotsCredits: 0,
        provider: null,
        signer: null
      };
      updateWalletUI();
      await updateXPDisplay();
      console.log('üîå Wallet disconnected, XP reset to 0');
    }

    function updateWalletUI() {
      const connectArea = document.getElementById('connect-area');
      const connectedArea = document.getElementById('connected-area');
      const addressEl = document.getElementById('address');

      if (appState.connected) {
        connectArea.style.display = 'none';
        connectedArea.style.display = 'block';
        addressEl.textContent = appState.address.slice(0,6) + '...' + appState.address.slice(-4);
      } else {
        connectArea.style.display = 'block';
        connectedArea.style.display = 'none';
      }
    }

    async function addXP(amount) {
      if (!appState.connected || !appState.address) {
        console.log('‚ùå Cannot add XP: wallet not connected');
        return;
      }
      
      // Add XP to current balance
      appState.xp = (appState.xp || 0) + amount;
      
      // Update display immediately
      document.getElementById('xp').textContent = appState.xp;
      
      // Save XP to Supabase in background (non-blocking)
      saveWalletXP(appState.address, appState.xp);
      
      // Update claim UI non-blocking
      requestAnimationFrame(() => updateClaimUI());
      
      // Add celebration effect
      const xpElement = document.getElementById('xp');
      xpElement.style.transform = 'scale(1.2)';
      xpElement.style.color = '#00ff00';
      
      setTimeout(() => {
        xpElement.style.transform = 'scale(1)';
        xpElement.style.color = 'white';
      }, 500);
      
      console.log(`‚ú® XP added to ${appState.address}: +${amount}, Total Available: ${appState.xp}`);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.className = `status visible ${type}`;
    }

    function hideStatus(id) {
      document.getElementById(id).className = 'status';
    }

    function showError(message) {
      const div = document.createElement('div');
      div.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:10px 20px;border-radius:8px;z-index:1000;';
      div.textContent = message;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Real transaction function
    async function executeTransaction(contractAddress, abi, methodName, statusId, successMsg, xpAmount) {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }

      if (appState.isTransactionPending) {
        showError('Please wait for the current transaction to complete');
        return;
      }

      try {
        console.log('üîó Starting transaction:', methodName);
        
        // Disable all action buttons
        disableAllActionButtons();
        
        showStatus(statusId, 'Preparing transaction...', 'pending');

        // Ensure Monad network
        await ensureMonadNetwork();

        // Create contract instance
        const contract = new ethers.Contract(contractAddress, abi, appState.signer);
        
        showStatus(statusId, 'üîê Please confirm in your wallet...', 'pending');

        // Send transaction
        const tx = await contract[methodName]({
          gasLimit: 100000
        });

        console.log('‚úÖ Transaction sent:', tx.hash);
        showStatus(statusId, `‚úÖ Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');

        // Since Farcaster wallet doesn't support eth_getTransactionReceipt,
        // we'll assume success after a delay
        setTimeout(async () => {
          console.log('‚úÖ Transaction assumed successful');
          showStatus(statusId, successMsg, 'success');
          await addXP(xpAmount);
          
          // Enable all buttons
          enableAllActionButtons();
          
          setTimeout(() => hideStatus(statusId), 3000);
        }, 5000);

      } catch (error) {
        console.error('‚ùå Transaction error:', error);
        
        // Enable all buttons on error
        enableAllActionButtons();
        
        let errorMsg = 'Transaction failed';
        if (error.message.includes('user rejected') || error.code === 4001) {
          errorMsg = 'Transaction cancelled by user';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient funds for gas';
        }

        showStatus(statusId, errorMsg, 'error');
        setTimeout(() => hideStatus(statusId), 5000);
      }
    }

    async function ensureMonadNetwork() {
      const MONAD_CHAIN_ID = '0x279F'; // 10143 in hex
      
      try {
        const provider = sdk && sdk.wallet && sdk.wallet.ethProvider 
          ? sdk.wallet.ethProvider 
          : window.ethereum;

        if (!provider) {
          throw new Error('No wallet provider available');
        }

        const chainId = await provider.request({ method: 'eth_chainId' });
        console.log('Current chain ID:', chainId);

        if (chainId !== MONAD_CHAIN_ID) {
          console.log('Switching to Monad Testnet...');
          
          try {
            await provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: MONAD_CHAIN_ID }],
            });
            console.log('Switched to Monad Testnet');
          } catch (switchError) {
            if (switchError.code === 4902) {
              console.log('Adding Monad Testnet...');
              await provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: MONAD_CHAIN_ID,
                  chainName: 'Monad Testnet',
                  nativeCurrency: {
                    name: 'Monad',
                    symbol: 'MONAD',
                    decimals: 18
                  },
                  rpcUrls: ['https://testnet-rpc.monad.xyz'],
                  blockExplorerUrls: ['https://testnet.monadscan.com/']
                }]
              });
              console.log('Monad Testnet added');
            }
          }

          // Recreate provider after network switch
          appState.provider = new ethers.providers.Web3Provider(provider);
          appState.signer = appState.provider.getSigner();
        }
      } catch (error) {
        console.error('Network switch error:', error);
        throw new Error('Failed to switch to Monad Testnet');
      }
    }

    // Farcaster Sharing Functions
    function generateShareableContent(type, data = {}) {
      const baseUrl = window.location.origin;
      const tokenBalance = document.getElementById('walletDogDisplay')?.textContent || '0';
      
      const shareTemplates = {
        pet: {
          text: `Just petted the Monad Dog! üêï‚ú®\n\nXP earned: ${appState.xp}\n$DOG Balance: ${tokenBalance}\n\nJoin me on Monad Testnet!`,
          url: `${baseUrl}?ref=pet&xp=${appState.xp}`,
          image: "üêï"
        },
        greet: {
          text: `GM Monad community! ‚òÄÔ∏èüëã\n\nCommunity XP: ${appState.xp}\n$DOG Tokens: ${tokenBalance}\n\nSpread the love on Monad!`,
          url: `${baseUrl}?ref=greet&xp=${appState.xp}`,
          image: "üëã"
        },
        flip: {
          text: `Just flipped a coin on Monad! ü™ô\n\nResult: ${data.result || 'Lucky'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}`,
          url: `${baseUrl}?ref=flip&result=${data.result}&xp=${appState.xp}`,
          image: "ü™ô"
        },
        slots: {
          text: `Just hit the slots on Monad Dog! üé∞\n\nResult: ${data.result || 'Spinning'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}\n\nTry your luck on Monad!`,
          url: `${baseUrl}?ref=slots&xp=${appState.xp}`,
          image: "üé∞"
        },
        claim: {
          text: `Just claimed ${data.amount || 0} $DOG tokens! üí∞\n\nTotal $DOG Balance: ${tokenBalance}\nXP reset - earning again!\n\nEarn XP and claim your $DOG tokens too!`,
          url: `${baseUrl}?ref=claim&tokens=${data.amount}`,
          image: "üí∞"
        },
        invite: {
          text: `Playing Monad Dog - the cutest way to explore Monad Testnet! üêï‚õìÔ∏è\n\n‚ú® Pet dogs, flip coins, say GM/GN\nüéØ Earn XP and claim $DOG tokens\nüí∞ Convert XP to tokens (10:1 rate)\nüöÄ Real blockchain interactions\n\nJoin me!`,
          url: `https://monad-snowy.vercel.app?ref=invite&inviter=${appState.address?.slice(0,6)}`,
          image: "üöÄ"
        }
      };
      
      return shareTemplates[type] || shareTemplates.invite;
    }

    function shareOnFarcaster(content) {
      try {
        if (sdk && sdk.actions && sdk.actions.openUrl) {
          // Use Farcaster SDK for sharing
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          sdk.actions.openUrl(shareUrl);
          console.log('üöÄ Shared via Farcaster SDK');
        } else {
          // Fallback to direct URL
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          window.open(shareUrl, '_blank');
          console.log('üöÄ Shared via direct URL');
        }
        
        // Track sharing event
        console.log('üìä Share event tracked:', content);
        
      } catch (error) {
        console.error('‚ùå Share error:', error);
        showError('Failed to open share dialog');
      }
    }

    // Achievement Modal Functions
    window.showAchievementModal = function(achievement) {
      const modal = document.getElementById('achievementModal');
      const icon = document.getElementById('achievementIcon');
      const title = document.getElementById('achievementTitle');
      const description = document.getElementById('achievementDescription');
      
      if (!modal || !icon || !title || !description) {
        console.error('Achievement modal elements not found');
        return;
      }
      
      icon.textContent = achievement.icon || 'üéâ';
      title.textContent = achievement.title || 'Achievement!';
      description.textContent = achievement.description || '';
      
      modal.style.display = 'flex';
      
      // Store current achievement for sharing
      window.currentAchievement = achievement;
      
      // Add escape key listener
      window.achievementEscapeHandler = function(e) {
        if (e.key === 'Escape') {
          closeAchievementModal();
        }
      };
      document.addEventListener('keydown', window.achievementEscapeHandler);
      
      console.log('üéâ Achievement modal shown:', achievement);
    }

    // Individual Share Functions
    window.sharePetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üêï',
        title: 'Dog Lover Achievement!',
        description: `You've been petting dogs and earned ${appState.xp} XP!`,
        type: 'pet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareGreetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üëã',
        title: 'Community Spirit!',
        description: `You've been greeting the community! Spreading love on Monad with ${appState.xp} XP.`,
        type: 'greet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareFlipAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const lastResult = document.getElementById('flip-result').textContent;
      const achievement = {
        icon: 'ü™ô',
        title: 'Lucky Flipper!',
        description: `${lastResult} You've been flipping coins on Monad with ${appState.xp} XP!`,
        type: 'flip',
        data: { result: lastResult }
      };
      
      showAchievementModal(achievement);
    };

    window.shareSlotsAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: 'üé∞',
        title: 'Slots Player!',
        description: `I've been playing Dog Slots on Monad! Current XP: ${appState.xp}. Try your luck!`,
        type: 'slots',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareAppWithFriends = function() {
      const achievement = {
        icon: 'üöÄ',
        title: 'Invite Friends!',
        description: 'Share Monad Dog with your friends and build the community together!',
        type: 'invite',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    // Start app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }

    console.log('üì± App script loaded');
    }); // End of DOMContentLoaded
  </script>
</body>
</html>
