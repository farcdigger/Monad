<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monad Dog</title>

<!-- Supabase Client -->
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Farcaster Manifest Link -->
  <link rel="manifest" href="/farcaster.json">
  <link rel="icon" type="image/png" href="https://monad-snowy.vercel.app/.well-known/icon.png">
  
  <!-- Farcaster Meta with Dynamic Content -->
  <meta name="fc:frame" content='{
    "version": "next",
    "imageUrl": "https://monad-snowy.vercel.app/.well-known/share.png",
    "button": {
      "title": "🐕 Play Monad Dog",
      "action": {
        "type": "launch_frame",
        "url": "https://monad-snowy.vercel.app",
        "name": "Monad Dog",
        "splashImageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
        "splashBackgroundColor": "#1e003e"
      }
    }
  }' />

  <!-- Open Graph for better sharing -->
  <meta property="og:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta property="og:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta property="og:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />
  <meta property="og:url" content="https://monad-snowy.vercel.app" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta name="twitter:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta name="twitter:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Farcaster Mini App SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/frame-sdk';
    
    // Mini App ready when loaded
    window.addEventListener('load', async () => {
      try {
        await sdk.actions.ready();
        console.log('Farcaster Mini App ready!');
        
        // Make SDK available globally
        window.farcasterSDK = sdk;
      } catch (error) {
        console.log('Not running in Farcaster client:', error);
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .social-link {
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      transition: all 0.3s ease;
      margin-top: 15px;
    }
    
    .social-link:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    
    .social-link svg {
      width: 20px;
      height: 20px;
      fill: white;
    }
    
    .xp {
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 20px;
    }
    
    .wallet-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background: #5855e8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tabs {
      display: flex;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab.active {
      background: #6366f1;
    }
    
    .content {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      min-height: 200px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .dog-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 20px auto;
      display: block;
    }
    
    .coin {
      font-size: 60px;
      margin: 20px;
      transition: transform 0.5s;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }
    
    .status.visible {
      display: block;
    }
    
    .status.success {
      background: rgba(0,255,0,0.2);
      color: #00ff00;
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
      color: #ff6b6b;
    }
    
    .status.pending {
      background: rgba(255,255,0,0.2);
      color: #ffeb3b;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    .loading-subtitle {
      font-size: 14px;
      opacity: 0.7;
      text-align: center;
      max-width: 280px;
      line-height: 1.4;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Skeleton Loading States */
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 16px;
      border-radius: 4px;
      margin: 8px 0;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-button {
      height: 44px;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Hide content initially to prevent layout shift */
    .app-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .app-content.loaded {
      opacity: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    th {
      background: rgba(255,255,255,0.1);
    }
    
    .address {
      font-family: monospace;
      font-size: 12px;
    }

    .badge {
      background: #ff6b9d;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .rank-number {
      font-weight: 600;
      color: #6366f1;
      width: 40px;
    }

    .address-cell {
      font-family: monospace;
      font-size: 12px;
    }

    .share-button {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin: 10px 5px;
      width: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
    }

    .share-section {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .achievement-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    .achievement-content {
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 350px;
      border: 2px solid #6366f1;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 0.6s ease;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      padding: 5px;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .close-modal:hover {
      opacity: 1;
    }

    /* Token Claim Styles */
    .token-stats {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      padding: 8px 16px;
      border-radius: 20px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
      font-size: 14px;
      font-weight: 600;
    }

    .claim-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .claim-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .claim-info-item {
      text-align: center;
    }

    .claim-info-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .claim-info-value {
      font-size: 20px;
      font-weight: 600;
      color: #f59e0b;
    }

    .claim-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 14px 28px;
      border-radius: 12px;
      width: 100%;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .claim-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .claim-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
    }

    .token-balance {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 10px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: 8px;
      font-size: 14px;
    }

    .conversion-rate {
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }

    .claim-history {
      margin-top: 20px;
      font-size: 12px;
      opacity: 0.7;
    }

    .claim-history-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* Slots Machine Styles */
    .slots-machine {
      background: rgba(255,255,255,0.1);
      padding: 25px;
      border-radius: 16px;
      margin: 20px 0;
      border: 2px solid rgba(255,255,255,0.2);
    }

    .slots-display {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 25px 0;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid #6366f1;
    }

    .slot-reel {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }

    .slot-reel.spinning {
      animation: spin-reel 0.1s linear infinite;
    }

    .slot-reel.winning {
      background: rgba(16, 185, 129, 0.3);
      border-color: #10b981;
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
    }

    @keyframes spin-reel {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }

    .slots-info {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .slots-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 12px;
      width: 100%;
      margin: 15px 0;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .slots-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .slots-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
      transform: none;
    }

    .slots-legend {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .symbol-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .symbol-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
    }

    .symbol {
      font-size: 24px;
    }

    .symbol-name {
      font-size: 14px;
      opacity: 0.8;
    }

    .slots-jackpot {
      background: linear-gradient(135deg, #ffd700, #ffed4a);
      color: #1a1a1a;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      text-align: center;
      font-weight: 600;
      animation: jackpot-glow 2s ease-in-out infinite;
    }

    @keyframes jackpot-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
    }
  </style>
</head>
<body>
  <div class="container app-content">
    <div class="header">
      <div class="title">🐕 Monad Dog</div>
      <div class="xp">✨ Available XP: <span id="xp">0</span></div>
      
      <a href="https://x.com/monaddogg" target="_blank" class="social-link" title="Follow us on Twitter">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
      </a>
    </div>

    <div class="wallet-section">
      <div id="connect-area">
        <button id="connect-btn">🟣 Connect Wallet</button>
      </div>
      <div id="connected-area" style="display: none;">
        <div>🟣 Connected</div>
        <div id="address" class="address"></div>
        <button id="disconnect-btn">Disconnect</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="showTab('pet')">🐕 Pet</button>
      <button class="tab" onclick="showTab('greet')">👋 Greet</button>
      <button class="tab" onclick="showTab('flip')">🪙 Flip</button>
      <button class="tab" onclick="showTab('slots')">🎰 Slots</button>
      <button class="tab" onclick="showTab('claim')">💰 Claim</button>
    </div>

    <div class="content">
      <!-- Pet Tab -->
      <div id="pet" class="tab-content active">
        <h3>Pet the Dog</h3>
        <img id="dog-img" class="dog-image" src="https://placedog.net/400/300?id=7" alt="Dog">
        <button onclick="petDog()">👋 Pet Dog (+10 XP)</button>
        <div id="pet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="sharePetAchievement()">
            🐕 Share Pet Achievement
          </button>
        </div>
      </div>

      <!-- Greet Tab -->
      <div id="greet" class="tab-content">
        <h3>Greet Community</h3>
        <p>Say GM or GN to the community!</p>
        <button onclick="sayGM()">☀️ Good Morning (+5 XP)</button>
        <button onclick="sayGN()">🌙 Good Night (+5 XP)</button>
        <div id="greet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareGreetAchievement()">
            👋 Share Community Spirit
          </button>
        </div>
      </div>

      <!-- Flip Tab -->
      <div id="flip" class="tab-content">
        <h3>Flip Coin</h3>
        <div class="coin" id="coin">🪙</div>
        <button onclick="flipCoin()">🎲 Flip Coin (+3 XP)</button>
        <div id="flip-result">Result will appear here</div>
        <div id="flip-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareFlipAchievement()">
            🪙 Share Lucky Moment
          </button>
        </div>
      </div>

              <!-- Slots Tab -->
      <div id="slots" class="tab-content">
        <h3>🎰 Dog Slots</h3>
        <p style="margin-bottom: 20px;">Match 4 same dogs or bones to win 5000 XP!</p>
        
        <div class="slots-machine">
          <div class="slots-display">
            <div class="slot-reel" id="reel1">🐕</div>
            <div class="slot-reel" id="reel2">🦮</div>
            <div class="slot-reel" id="reel3">🐶</div>
            <div class="slot-reel" id="reel4">🦴</div>
          </div>
          
          <div class="slots-info">
            <div class="cost-info">
              <span style="color: #f59e0b;">💰 Pay: 0.1 MONAD = 2 Credits</span>
            </div>
            <div class="prize-info">
              <span style="color: #10b981;">🏆 4 Match = 5000 XP</span>
            </div>
          </div>
          
          <button class="slots-button" id="slotsButton" onclick="playSlots()">
            🔒 Connect Wallet
          </button>
          
          <div id="slots-status" class="status"></div>
        </div>
        
        <div class="slots-legend">
          <h4 style="margin: 20px 0 10px 0;">How It Works:</h4>
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: left;">
            <p style="margin-bottom: 8px;">💰 <strong>Pay 0.1 MONAD</strong> → Get 2 game credits</p>
            <p style="margin-bottom: 8px;">🎮 <strong>Each game</strong> → Uses 1 credit</p>
            <p style="margin-bottom: 8px;">✅ <strong>Credits awarded</strong> → Only after TX confirms</p>
            <p>🎰 <strong>Play anytime</strong> → Use your available credits</p>
          </div>
          
          <h4 style="margin: 20px 0 10px 0;">Symbols & Prizes:</h4>
          <div class="symbol-grid">
            <div class="symbol-item">
              <span class="symbol">🐕</span>
              <span class="symbol-name">Shiba</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">🦮</span>
              <span class="symbol-name">Guide Dog</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">🐶</span>
              <span class="symbol-name">Puppy</span>
            </div>
            <div class="symbol-item">
              <span class="symbol">🦴</span>
              <span class="symbol-name">Bone</span>
            </div>
          </div>
          
          <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 15px; text-align: left;">
            <p style="margin-bottom: 5px;">🎉 <strong>4 Same:</strong> 5000 XP (JACKPOT!)</p>
            <p style="margin-bottom: 5px;">🏆 <strong>3 Same:</strong> 500 XP</p>
            <p>✨ <strong>2 Same:</strong> 50 XP</p>
          </div>
        </div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareSlotsAchievement()">
            🎰 Share Slots Win
          </button>
        </div>
      </div>

      <!-- Claim Tab -->
      <div id="claim" class="tab-content">
        <h3>Claim $DOG Tokens</h3>
        <p style="margin-bottom: 20px;">Convert your earned XP to $DOG tokens!</p>
        
        <div class="claim-section">
          <div class="claim-info">
            <div class="claim-info-item">
              <div class="claim-info-label">Available XP</div>
              <div class="claim-info-value" id="claimableXP">0</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">→</div>
              <div style="font-size: 30px;">🔄</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">$DOG Tokens</div>
              <div class="claim-info-value" id="claimableDOG">0</div>
            </div>
          </div>
          
          <button class="claim-button" id="claimButton" onclick="claimTokens()" disabled>
            💰 Claim $DOG Tokens
          </button>
          
          <div class="conversion-rate">
            Conversion Rate: 10 XP = 1 $DOG Token
          </div>
          
          <div id="claim-status" class="status"></div>
        </div>
        
        <!-- Token Info -->
        <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 12px;">
          <div style="text-align: center; margin-bottom: 15px;">
            <h4 style="margin-bottom: 10px;">🐕 $DOG Token Info</h4>
            <p style="font-size: 12px; opacity: 0.7;">Claim your tokens and they'll be minted directly to your wallet</p>
          </div>
          
          <!-- Wallet DOG Balance Display -->
          <div style="background: linear-gradient(135deg, #f59e0b, #eab308); padding: 20px; border-radius: 12px; text-align: center; margin: 15px 0;">
            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Your Wallet Balance</div>
            <div style="font-size: 32px; font-weight: 700;">
              <span id="walletDogDisplay">0</span> $DOG
            </div>
            <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">🪙 Monad Testnet</div>
          </div>
          
          <div style="margin-top: 15px; text-align: center;">
            <a href="https://testnet.monadscan.com/address/0x1f6649d028c4c146c050a9b224115a01c92a02f3" 
               target="_blank" 
               class="share-button" 
               style="background: rgba(255,255,255,0.1); font-size: 12px; padding: 8px 16px;">
              🔍 View Token Contract
            </a>
          </div>
        </div>
      </div>
    </div>

    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Monad Dog...</div>
      <div class="loading-subtitle">Starting Monad Dog...<br>🚀 Initializing blockchain connection</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loadingProgressBar"></div>
      </div>
    </div>

    <!-- Achievement Modal -->
    <div id="achievementModal" class="achievement-modal" onclick="if(event.target === this) closeAchievementModal()">
      <div class="achievement-content">
        <button class="close-modal" onclick="closeAchievementModal()">×</button>
        <div id="achievementIcon" class="achievement-icon">🎉</div>
        <h3 id="achievementTitle">Achievement Unlocked!</h3>
        <p id="achievementDescription">You did something awesome!</p>
        <div style="margin-top: 20px;">
          <button class="share-button" onclick="shareCurrentAchievement()">
            📢 Share on Farcaster
          </button>
          <button class="share-button" onclick="closeAchievementModal()" style="background: rgba(255,255,255,0.2);">
            ✨ Continue Playing
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Wait for Supabase to load
    window.addEventListener('DOMContentLoaded', function() {
      // Supabase Configuration
      const SUPABASE_URL = 'https://uhqszfoekqrjtybrwqzt.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVocXN6Zm9la3FyanR5YnJ3cXp0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4MDMxNTAsImV4cCI6MjA2NjM3OTE1MH0.gGch8B6AlvGrZTDVjfd0xidVnh_Dsua4qRxbaixBqM0';
      
      // Initialize Supabase
      let supabaseClient;
      if (window.supabase) {
        const { createClient } = window.supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('✅ Supabase initialized');
      } else {
        console.error('❌ Supabase not loaded');
      }
    
      // Initialize modal close functions globally
      window.closeAchievementModal = function() {
        const modal = document.getElementById('achievementModal');
        if (modal) {
          modal.style.display = 'none';
        }
        window.currentAchievement = null;
        
        // Remove escape key listener
        if (window.achievementEscapeHandler) {
          document.removeEventListener('keydown', window.achievementEscapeHandler);
        }
        
        console.log('Modal closed');
      }
      
      window.shareCurrentAchievement = function() {
        if (window.currentAchievement) {
          try {
            const content = generateShareableContent(window.currentAchievement.type, window.currentAchievement.data);
            shareOnFarcaster(content);
            
            // Close modal after sharing
            setTimeout(() => {
              closeAchievementModal();
            }, 500);
          } catch (error) {
            console.error('Error sharing achievement:', error);
            closeAchievementModal();
          }
        }
      }
      
      console.log('🚀 Starting app...');

    // Enhanced Loading Management
    let loadingProgress = 0;
    let isAppReady = false;
    let activeTab = 'pet';

    function updateLoadingProgress(progress, message) {
      const progressBar = document.getElementById('loadingProgressBar');
      const subtitle = document.querySelector('.loading-subtitle');
      
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      if (subtitle && message) {
        subtitle.innerHTML = message;
      }
      
      loadingProgress = progress;
      console.log(`📊 Loading progress: ${progress}% - ${message}`);
    }

    function showLoadingState() {
      document.getElementById('loading').style.display = 'flex';
      document.querySelector('.app-content').classList.remove('loaded');
      updateLoadingProgress(0, 'Starting Monad Dog...<br>🚀 Initializing blockchain connection');
    }

    function hideLoadingState() {
      // Don't hide immediately - show completion
      updateLoadingProgress(100, 'Ready to play! 🎉<br>Welcome to Monad Dog!');
      
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.querySelector('.app-content').classList.add('loaded');
        isAppReady = true;
        
        // Call Farcaster ready action
        if (sdk && sdk.actions && sdk.actions.ready) {
          sdk.actions.ready({
            disableNativeGestures: false // Allow native gestures for better UX
          }).then(() => {
            console.log('✅ Farcaster SDK ready called successfully');
          }).catch(error => {
            console.log('⚠️ Farcaster SDK ready failed:', error);
          });
        }
        
        console.log('🎉 App fully loaded and ready');
      }, 500);
    }

    // Contract addresses and ABIs
    const CONTRACTS = {
      PET: "0xc53abe4c593b9440407f8ac1b346f3f999e6d8ed",
      GREET: "0xbc8b78f3e2348d4b5e0390fe700ce54b59931da4",
      FLIP: "0xc5b2280d1e2f155f9a2be2af7e78190658874106",
      SLOTS: "0xc7011f245aa51fa488783d5b0cfc6e0cba86f6cb", // ✅ DEPLOYED SLOTS CONTRACT
      DOG_TOKEN: "0xeBADdacB0DB2ddfb78e110595D36F859a3579294"
    };

    const ABIS = {
      PET: ["function pet() public"],
      GREET: ["function gm() public", "function gn() public"],
      FLIP: ["function flip() public"],
      SLOTS: [
        "function buyCredits() external payable",
        "function playSlots() external returns (uint8[4])",
        "function getCredits(address player) external view returns (uint256)",
        "function getGameStats() external view returns (uint256, uint256, uint256)",
        "event CreditsPurchased(address indexed player, uint256 credits, uint256 cost)",
        "event GamePlayed(address indexed player, uint8[4] results, uint256 creditsRemaining)",
        "event Jackpot(address indexed player, uint8 symbol, uint256 prize)"
      ],
      DOG_TOKEN: [
        "function claim(uint256 xpAmount) public",
        "function balanceOf(address account) public view returns (uint256)",
        "function decimals() public view returns (uint8)",
        "function symbol() public view returns (string)",
        "function totalSupply() public view returns (uint256)",
        "function getClaimedXP(address user) public view returns (uint256)",
        "function totalMinted() public view returns (uint256)",
        "event TokensClaimed(address indexed user, uint256 xpAmount, uint256 tokenAmount)"
      ]
    };

    // XP to DOG token conversion rate
    const XP_TO_DOG_RATE = 10; // 10 XP = 1 DOG token

    // Global state 
    let appState = {
      connected: false,
      address: null,
      xp: 0, // Available XP (can be used for claiming)
      slotsCredits: 0, // Available slots game credits
      provider: null,
      signer: null,
      isTransactionPending: false
    };

    // Initialize SDK
    let sdk = null;
    
    // Supabase Functions for XP Management - Simplified for reset-based system
    async function getWalletXP(address) {
      if (!address) return 0;
      
      try {
        // Check if Supabase is available
        if (!supabaseClient) {
          console.log('Supabase not available, using localStorage fallback');
          return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
        }

        const { data, error } = await supabaseClient
          .from('user_xp')
          .select('xp')
          .eq('wallet_address', address.toLowerCase())
          .single();
        
        if (error) {
          console.log('No XP record found, returning 0');
          // Fallback to localStorage
          return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
        }
        
        return data.xp || 0;
      } catch (e) {
        console.error('Error fetching XP:', e);
        // Fallback to localStorage
        return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
      }
    }

    async function saveWalletXP(address, xp) {
      if (!address) return;
      
      // Always save to localStorage first (immediate)
      localStorage.setItem(`wallet_xp_${address.toLowerCase()}`, xp.toString());
      
      // Then try Supabase (async, non-blocking)
      if (supabaseClient) {
        supabaseClient
          .from('user_xp')
          .upsert({
            wallet_address: address.toLowerCase(),
            xp: xp,
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'wallet_address'
          })
          .then(({ error }) => {
            if (!error) {
              console.log(`💾 XP saved to Supabase for ${address}: ${xp}`);
            }
          })
          .catch(e => {
            console.error('Error saving XP to Supabase:', e);
          });
      }
    }

    // ✅ SLOTS CREDITS MANAGEMENT - Updated with real contract integration
    async function getSlotsCredits(address) {
      if (!address || !appState.provider) return 0;
      
      try {
        // Get credits from smart contract
        const slotsContract = new ethers.Contract(
          CONTRACTS.SLOTS,
          ABIS.SLOTS,
          appState.provider
        );
        
        const credits = await slotsContract.getCredits(address);
        return credits.toNumber();
      } catch (e) {
        console.error('Error fetching slots credits from contract:', e);
        // Fallback to localStorage
        return parseInt(localStorage.getItem(`slots_credits_${address.toLowerCase()}`) || '0');
      }
    }

    async function saveSlotsCredits(address, credits) {
      if (!address) return;
      
      // Save to localStorage for immediate display
      localStorage.setItem(`slots_credits_${address.toLowerCase()}`, credits.toString());
      
      // Note: Actual credits are managed by smart contract
      // This is just for UI consistency
    }

    async function updateSlotsCreditsDisplay() {
      if (appState.connected && appState.address) {
        const credits = await getSlotsCredits(appState.address);
        appState.slotsCredits = credits;
        
        // Update slots button text
        updateSlotsButton();
        
        console.log(`🎰 Slots Credits - Available: ${credits}`);
      } else {
        appState.slotsCredits = 0;
        updateSlotsButton();
      }
    }

    function updateSlotsButton() {
      const slotsButton = document.getElementById('slotsButton');
      if (!slotsButton) return;
      
      if (appState.slotsCredits > 0) {
        slotsButton.textContent = `🎰 Play Slots (${appState.slotsCredits} credits)`;
        slotsButton.disabled = false;
      } else if (appState.connected) {
        slotsButton.textContent = `💰 Buy 2 Credits (0.1 MONAD)`;
        slotsButton.disabled = false;
      } else {
        slotsButton.textContent = `🔒 Connect Wallet`;
        slotsButton.disabled = true;
      }
    }

    async function updateXPDisplay() {
      if (appState.connected && appState.address) {
        // Show current value immediately
        const currentDisplay = document.getElementById('xp').textContent;
        
        // Get XP (with timeout to prevent hanging)
        const xpPromise = getWalletXP(appState.address);
        const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(parseInt(currentDisplay) || 0), 1000));
        
        const walletXP = await Promise.race([xpPromise, timeoutPromise]);
        
        document.getElementById('xp').textContent = walletXP;
        appState.xp = walletXP;
        
        // Also update slots credits
        await updateSlotsCreditsDisplay();
        
        console.log(`📊 XP Display - Available: ${walletXP}`);
        
        // Update claim UI non-blocking
        if (activeTab === 'claim') {
          requestAnimationFrame(() => updateClaimUI());
        }
      } else {
        document.getElementById('xp').textContent = '0';
        appState.xp = 0;
        appState.slotsCredits = 0;
        updateClaimUI();
        updateSlotsButton();
      }
    }

    // Update claim UI based on current XP
    async function updateClaimUI() {
      const claimableXP = appState.xp || 0;
      const claimableDOG = Math.floor(claimableXP / XP_TO_DOG_RATE);
      
      document.getElementById('claimableXP').textContent = claimableXP;
      document.getElementById('claimableDOG').textContent = claimableDOG;
      
      const claimButton = document.getElementById('claimButton');
      if (claimableXP >= XP_TO_DOG_RATE && appState.connected) {
        claimButton.disabled = false;
        claimButton.textContent = `💰 Claim ${claimableDOG} $DOG Tokens`;
      } else {
        claimButton.disabled = true;
        if (!appState.connected) {
          claimButton.textContent = '🔒 Connect Wallet First';
        } else if (claimableXP < XP_TO_DOG_RATE) {
          claimButton.textContent = `📈 Need ${XP_TO_DOG_RATE - claimableXP} more XP`;
        }
      }
      
      // Update token balance
      await updateTokenBalance();
    }

    // Update token balance display
    async function updateTokenBalance() {
      if (!appState.connected || !appState.provider || !appState.address) {
        console.log('❌ Not connected, cannot fetch balance');
        document.getElementById('walletDogDisplay').textContent = '0';
        return;
      }
      
      console.log('🔄 Fetching DOG balance for:', appState.address);
      
      try {
        // Check if we're using Farcaster wallet
        const isFarcasterWallet = sdk && sdk.wallet && sdk.wallet.ethProvider;
        
        if (isFarcasterWallet) {
          console.log('🟣 Using Farcaster wallet - trying direct RPC call');
          
          try {
            // Encode the balanceOf function call
            const iface = new ethers.utils.Interface([
              "function balanceOf(address account) public view returns (uint256)"
            ]);
            const data = iface.encodeFunctionData("balanceOf", [appState.address]);
            
            // Make the call using the provider's send method
            const result = await appState.provider.send("eth_call", [{
              to: CONTRACTS.DOG_TOKEN,
              data: data
            }, "latest"]);
            
            console.log('Raw result:', result);
            
            if (result && result !== '0x') {
              const balance = ethers.BigNumber.from(result);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`✅ DOG Balance (Farcaster): ${displayBalance}`);
            } else {
              console.log('No balance or contract not found');
              document.getElementById('walletDogDisplay').textContent = '0';
            }
            
          } catch (callError) {
            console.error('Direct eth_call failed:', callError);
            
            // Fallback: Try using a public RPC endpoint
            console.log('Trying fallback RPC...');
            try {
              const fallbackProvider = new ethers.providers.JsonRpcProvider('https://testnet-rpc.monad.xyz');
              const dogTokenContract = new ethers.Contract(
                CONTRACTS.DOG_TOKEN,
                ["function balanceOf(address) view returns (uint256)"],
                fallbackProvider
              );
              
              const balance = await dogTokenContract.balanceOf(appState.address);
              const formattedBalance = ethers.utils.formatUnits(balance, 18);
              const numBalance = parseFloat(formattedBalance);
              const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                                   numBalance > 0 ? numBalance.toFixed(6) : '0';
              
              document.getElementById('walletDogDisplay').textContent = displayBalance;
              console.log(`✅ DOG Balance (Fallback RPC): ${displayBalance}`);
              
            } catch (fallbackError) {
              console.error('Fallback RPC also failed:', fallbackError);
              document.getElementById('walletDogDisplay').textContent = '0';
            }
          }
          
        } else {
          // Regular wallet (MetaMask, etc.)
          console.log('🦊 Using regular wallet provider');
          
          const dogTokenContract = new ethers.Contract(
            CONTRACTS.DOG_TOKEN,
            ["function balanceOf(address) view returns (uint256)"],
            appState.provider
          );
          
          const balance = await dogTokenContract.balanceOf(appState.address);
          const formattedBalance = ethers.utils.formatUnits(balance, 18);
          const numBalance = parseFloat(formattedBalance);
          const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : 
                               numBalance > 0 ? numBalance.toFixed(6) : '0';
          
          document.getElementById('walletDogDisplay').textContent = displayBalance;
          console.log(`✅ DOG Balance: ${displayBalance}`);
        }
        
      } catch (error) {
        console.error('❌ Error fetching token balance:', error);
        
        // Last resort: Use localStorage cache if available
        const cachedBalance = localStorage.getItem(`dog_balance_${appState.address.toLowerCase()}`);
        if (cachedBalance) {
          document.getElementById('walletDogDisplay').textContent = cachedBalance;
          console.log(`📦 Using cached balance: ${cachedBalance}`);
        } else {
          document.getElementById('walletDogDisplay').textContent = '0';
        }
      }
    }

    // ✅ FIXED CLAIM FUNCTION - XP resets after user confirms transaction + Button cooldown
    window.claimTokens = async function() {
      if (!appState.connected || !appState.signer) {
        showError('Please connect your wallet first');
        return;
      }
      
      const availableXP = appState.xp;
      const claimableDOG = Math.floor(availableXP / XP_TO_DOG_RATE);
      
      if (availableXP < XP_TO_DOG_RATE) {
        showError(`Need at least ${XP_TO_DOG_RATE} XP to claim tokens`);
        return;
      }
      
      const claimButton = document.getElementById('claimButton');
      
      try {
        console.log('💰 Starting token claim...');
        
        // ✅ Disable button immediately for 30 seconds
        claimButton.disabled = true;
        
        // Start countdown
        let countdown = 30;
        const originalText = claimButton.textContent;
        
        const countdownInterval = setInterval(() => {
          countdown--;
          claimButton.textContent = `⏳ Please wait ${countdown}s...`;
          
          if (countdown <= 0) {
            clearInterval(countdownInterval);
            // Re-enable button and update text after countdown
            updateClaimUI();
          }
        }, 1000);
        
        showStatus('claim-status', '🔐 Please confirm transaction in your wallet...', 'pending');
        
        // Ensure correct network
        await ensureMonadNetwork();
        
        // Call the actual DOG token contract
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          ABIS.DOG_TOKEN,
          appState.signer
        );
        
        // Calculate XP to claim (must be multiple of 10)
        const xpToClaim = claimableDOG * XP_TO_DOG_RATE;
        
        console.log(`Claiming ${xpToClaim} XP for ${claimableDOG} DOG tokens`);
        
        // Execute claim transaction with proper gas limit
        const tx = await dogTokenContract.claim(xpToClaim, {
          gasLimit: 100000
        });
        
        // ✅ USER CONFIRMED TRANSACTION - NOW RESET XP IMMEDIATELY
        console.log('🎯 Transaction confirmed by user - resetting XP to 0');
        
        // Reset XP to 0 in state and display immediately
        appState.xp = 0;
        document.getElementById('xp').textContent = '0';
        
        // ✅ Save XP as 0 to Supabase immediately
        await saveWalletXP(appState.address, 0);
        
        // Update claim UI immediately
        await updateClaimUI();
        
        showStatus('claim-status', `📡 Transaction sent: ${tx.hash.slice(0,10)}... XP reset to 0`, 'pending');
        console.log('Transaction hash:', tx.hash);
        console.log('✅ XP successfully reset to 0 - user can continue earning');
        
        // Wait for confirmation and update balance
        setTimeout(async () => {
          try {
            // Try to get updated balance with multiple retries
            const updateBalanceWithRetry = async (retries = 3) => {
              for (let i = 0; i < retries; i++) {
                try {
                  await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                  
                  const newBalance = await dogTokenContract.balanceOf(appState.address);
                  const decimals = await dogTokenContract.decimals();
                  const formattedBalance = ethers.utils.formatUnits(newBalance, decimals);
                  
                  const numBalance = parseFloat(formattedBalance);
                  const displayBalance = numBalance >= 1 ? numBalance.toFixed(2) : numBalance.toFixed(6);
                  
                  document.getElementById('walletDogDisplay').textContent = displayBalance;
                  
                  // Cache the balance
                  localStorage.setItem(`dog_balance_${appState.address.toLowerCase()}`, displayBalance);
                  
                  console.log(`✅ Balance updated after claim (attempt ${i + 1}): ${displayBalance} DOG`);
                  break;
                } catch (e) {
                  console.log(`Balance update attempt ${i + 1} failed, retrying...`);
                }
              }
            };
            
            updateBalanceWithRetry();
            
            showStatus('claim-status', `✅ Successfully claimed ${claimableDOG} $DOG tokens! XP reset - start earning again!`, 'success');
            
            // Show achievement
            showAchievementModal({
              icon: '💰',
              title: 'Tokens Claimed!',
              description: `You've successfully claimed ${claimableDOG} $DOG tokens! Your XP has been reset - start earning again!`,
              type: 'claim',
              data: { amount: claimableDOG }
            });
            
            setTimeout(() => hideStatus('claim-status'), 8000);
            
          } catch (e) {
            console.log('Post-claim update error:', e);
            showStatus('claim-status', `✅ Claim transaction sent! Tokens will arrive soon. XP reset successfully.`, 'success');
            setTimeout(() => hideStatus('claim-status'), 8000);
          }
        }, 5000);
        
      } catch (error) {
        console.error('❌ Claim error:', error);
        
        let errorMsg = 'Failed to claim tokens';
        
        if (error.message.includes('user rejected')) {
          errorMsg = 'Transaction cancelled - XP not affected';
          // Don't reset XP if user cancelled
          console.log('🚫 Transaction cancelled - XP remains unchanged');
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient gas funds';
        } else if (error.message.includes('XP already claimed')) {
          errorMsg = 'This XP has already been claimed';
          // Reset XP if already claimed on contract
          appState.xp = 0;
          await saveWalletXP(appState.address, 0);
          await updateXPDisplay();
        } else if (error.message.includes('Invalid XP amount')) {
          errorMsg = 'Invalid XP amount. Must be multiple of 10';
        }
        
        showStatus('claim-status', errorMsg, 'error');
        setTimeout(() => hideStatus('claim-status'), 5000);
      }
    };

    async function initializeAppWithProgress() {
      try {
        showLoadingState();
        
        // Step 1: Initialize SDK
        updateLoadingProgress(20, 'Loading Farcaster SDK...<br>🔗 Connecting to Frame environment');
        
        try {
          const module = await import('https://esm.sh/@farcaster/frame-sdk');
          sdk = module.sdk;
          console.log('SDK loaded:', !!sdk);
          
          if (sdk) {
            updateLoadingProgress(40, 'Farcaster SDK loaded! ✅<br>📱 Setting up Mini App environment');
            await sdk.actions.ready();
            console.log('SDK ready');
          }
        } catch (e) {
          console.log('SDK not available:', e.message);
          updateLoadingProgress(40, 'Running in standalone mode<br>🌐 Browser environment detected');
        }

        // Step 2: Setup game functions
        updateLoadingProgress(60, 'Setting up game functions...<br>🎮 Preparing blockchain interactions');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        setupEventListeners();
        setupGameFunctions();
        
        // Step 3: Initialize app
        updateLoadingProgress(80, 'Initializing app...<br>🎮 Setting up game');
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Step 4: Finalize
        updateLoadingProgress(95, 'Almost ready...<br>✨ Final preparations');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        hideLoadingState();
        console.log('✅ App initialized successfully with progress tracking');
        
      } catch (error) {
        console.error('❌ Init error:', error);
        updateLoadingProgress(100, 'Error occurred, but app will continue<br>⚠️ Some features may be limited');
        
        setTimeout(() => {
          hideLoadingState();
        }, 1000);
      }
    }

    async function initApp() {
      await initializeAppWithProgress();
    }

    function setupEventListeners() {
      document.getElementById('connect-btn').onclick = connectWallet;
      document.getElementById('disconnect-btn').onclick = disconnect;
    }

    // Disable all action buttons during transaction
    function disableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = true;
          button.dataset.originalText = button.textContent;
        }
      });
      
      appState.isTransactionPending = true;
    }

    // Enable all action buttons after transaction
    function enableAllActionButtons() {
      const buttons = [
        ...document.querySelectorAll('#pet button'),
        ...document.querySelectorAll('#greet button'),
        ...document.querySelectorAll('#flip button'),
        document.getElementById('claimButton')
      ];
      
      buttons.forEach(button => {
        if (button && !button.id.includes('disconnect') && !button.classList.contains('tab') && !button.classList.contains('share-button')) {
          button.disabled = false;
          if (button.dataset.originalText) {
            button.textContent = button.dataset.originalText;
            delete button.dataset.originalText;
          }
        }
      });
      
      appState.isTransactionPending = false;
      
      // Update claim button state
      if (activeTab === 'claim') {
        updateClaimUI();
      }
    }

    function setupGameFunctions() {
      // Define all game functions globally
      window.petDog = async function() {
        console.log('🐕 Pet Dog clicked!');
        
        if (!appState.connected) {
          console.log('❌ Wallet not connected');
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        console.log('✅ Wallet connected, starting pet transaction');
        
        // Change dog image
        document.getElementById('dog-img').src = `https://placedog.net/400/300?id=${Math.floor(Math.random() * 50) + 1}`;
        
        // Execute real blockchain transaction
        await executeTransaction(
          CONTRACTS.PET,
          ABIS.PET,
          'pet',
          'pet-status',
          '🐕 Dog petted successfully! +10 XP',
          10
        );
      };

      window.sayGM = async function() {
        console.log('☀️ Say GM clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gm',
          'greet-status',
          '☀️ Good Morning sent! +5 XP',
          5
        );
      };

      window.sayGN = async function() {
        console.log('🌙 Say GN clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gn',
          'greet-status',
          '🌙 Good Night sent! +5 XP',
          5
        );
      };

      window.flipCoin = async function() {
        console.log('🪙 Flip Coin clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const coin = document.getElementById('coin');
        const result = document.getElementById('flip-result');
        
        // Start visual animation
        result.textContent = 'Flipping...';
        let rotation = 0;
        const interval = setInterval(() => {
          rotation += 180;
          coin.style.transform = `rotateY(${rotation}deg)`;
        }, 100);
        
        // Execute real transaction
        await executeTransaction(
          CONTRACTS.FLIP,
          ABIS.FLIP,
          'flip',
          'flip-status',
          '🪙 Coin flipped! +3 XP',
          3
        );
        
        // Stop animation after transaction starts
        setTimeout(() => {
          clearInterval(interval);
          const finalResult = Math.random() < 0.5 ? 'Heads' : 'Tails';
          coin.style.transform = `rotateY(${finalResult === 'Heads' ? 0 : 180}deg)`;
          result.textContent = `Result: ${finalResult}!`;
        }, 3000);
      };

      // ✅ SLOTS GAME FUNCTION - REDESIGNED WITH CREDITS SYSTEM
      window.playSlots = async function() {
        console.log('🎰 Play Slots clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        if (appState.isTransactionPending) {
          showError('Please wait for the current transaction to complete');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        // Check if user has credits or needs to buy
        if (appState.slotsCredits > 0) {
          // USE EXISTING CREDIT
          await playSlotGame();
        } else {
          // BUY CREDITS WITH 0.1 MONAD
          await buySlotCredits();
        }
      };

      // Buy slot credits with 0.1 MONAD payment - REAL CONTRACT VERSION
      async function buySlotCredits() {
        const slotsButton = document.getElementById('slotsButton');
        const originalText = slotsButton.textContent;
        
        try {
          // Disable button immediately
          slotsButton.disabled = true;
          slotsButton.textContent = '💰 Buying Credits...';
          
          showStatus('slots-status', '🔐 Please confirm payment of 0.1 MONAD for 2 game credits...', 'pending');
          
          // Ensure correct network
          await ensureMonadNetwork();
          
          // ✅ REAL CONTRACT CALL
          const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, ABIS.SLOTS, appState.signer);
          
          // Send transaction with 0.1 MONAD payment
          const tx = await slotsContract.buyCredits({
            value: ethers.utils.parseEther("0.1"), // 0.1 MONAD
            gasLimit: 100000
          });
          
          console.log('✅ Credits purchase transaction sent:', tx.hash);
          showStatus('slots-status', `📡 Payment sent: ${tx.hash.slice(0,10)}... Waiting for confirmation...`, 'pending');
          
          // Wait for transaction confirmation
          setTimeout(async () => {
            try {
              // ✅ GET CREDITS FROM CONTRACT
              const credits = await slotsContract.getCredits(appState.address);
              appState.slotsCredits = credits.toNumber();
              
              // Save to localStorage for immediate display
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              updateSlotsButton();
              
              showStatus('slots-status', `✅ Payment confirmed! You have ${appState.slotsCredits} game credits!`, 'success');
              console.log(`✅ ${appState.slotsCredits} slots credits confirmed from contract`);
              
              setTimeout(() => hideStatus('slots-status'), 3000);
            } catch (e) {
              console.error('Error getting credits after purchase:', e);
              // Fallback: assume 2 credits were added
              appState.slotsCredits += 2;
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              updateSlotsButton();
              
              showStatus('slots-status', '✅ Payment confirmed! Credits should be available soon.', 'success');
              setTimeout(() => hideStatus('slots-status'), 3000);
            }
          }, 5000);
          
        } catch (error) {
          console.error('❌ Payment error:', error);
          
          slotsButton.disabled = false;
          slotsButton.textContent = originalText;
          
          let errorMsg = 'Payment failed';
          if (error.message.includes('user rejected')) {
            errorMsg = 'Payment cancelled';
          } else if (error.message.includes('insufficient funds')) {
            errorMsg = 'Insufficient MONAD balance';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Play the actual slot game using 1 credit - REAL CONTRACT VERSION
      async function playSlotGame() {
        if (appState.slotsCredits <= 0) {
          showError('No game credits available');
          return;
        }
        
        const slotsButton = document.getElementById('slotsButton');
        
        try {
          // Disable button during game
          slotsButton.disabled = true;
          slotsButton.textContent = '🎰 Playing...';
          
          console.log(`🎮 Playing slots with contract, current credits: ${appState.slotsCredits}`);
          showStatus('slots-status', '🎰 Spinning the reels...', 'pending');
          
          // ✅ REAL CONTRACT CALL
          const slotsContract = new ethers.Contract(CONTRACTS.SLOTS, ABIS.SLOTS, appState.signer);
          
          // Play slots on contract (uses 1 credit automatically)
          const tx = await slotsContract.playSlots({
            gasLimit: 150000
          });
          
          console.log('✅ Slots game transaction sent:', tx.hash);
          
          // Start visual animation while waiting for result
          const symbols = ['🐕', '🦮', '🐶', '🦴'];
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          
          // Spinning animation
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.add('spinning');
          });
          
          let spinDuration = 4000; // 4 seconds of spinning
          
          const spinInterval = setInterval(() => {
            reels.forEach(reelId => {
              const reel = document.getElementById(reelId);
              reel.textContent = symbols[Math.floor(Math.random() * symbols.length)];
            });
          }, 100);
          
          // Wait for transaction and get results
          setTimeout(async () => {
            clearInterval(spinInterval);
            
            try {
              // Get transaction receipt to see events
              const receipt = await appState.provider.getTransactionReceipt(tx.hash);
              
              // Parse game results from events (simplified - in real implementation you'd parse the event)
              // For now, generate results based on transaction hash for deterministic results
              const results = [];
              const txHash = tx.hash;
              for (let i = 0; i < 4; i++) {
                const byte = parseInt(txHash.slice(2 + i * 2, 4 + i * 2), 16);
                results.push(symbols[byte % 4]);
              }
              
              // Display final results
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Update credits from contract
              const newCredits = await slotsContract.getCredits(appState.address);
              appState.slotsCredits = newCredits.toNumber();
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              console.log(`🎮 Game completed, remaining credits: ${appState.slotsCredits}`);
              
              // Check for winning combinations and award XP
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
              
            } catch (e) {
              console.error('Error processing game result:', e);
              
              // Fallback: Generate random results and update credits
              const results = [];
              for (let i = 0; i < 4; i++) {
                results.push(symbols[Math.floor(Math.random() * symbols.length)]);
              }
              
              reels.forEach((reelId, index) => {
                const reel = document.getElementById(reelId);
                reel.classList.remove('spinning');
                reel.textContent = results[index];
              });
              
              // Assume 1 credit was used
              appState.slotsCredits = Math.max(0, appState.slotsCredits - 1);
              await saveSlotsCredits(appState.address, appState.slotsCredits);
              
              setTimeout(() => {
                checkSlotsWin(results);
                updateSlotsButton();
              }, 500);
            }
          }, spinDuration);
          
        } catch (error) {
          console.error('❌ Game error:', error);
          
          // Stop spinning animation
          const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
          reels.forEach(reelId => {
            const reel = document.getElementById(reelId);
            reel.classList.remove('spinning');
          });
          
          updateSlotsButton();
          
          let errorMsg = 'Game failed';
          if (error.message.includes('No credits available')) {
            errorMsg = 'No credits available';
          } else if (error.message.includes('user rejected')) {
            errorMsg = 'Game cancelled';
          }
          
          showStatus('slots-status', errorMsg, 'error');
          setTimeout(() => hideStatus('slots-status'), 5000);
        }
      }

      // Check slots winning combinations
      function checkSlotsWin(results) {
        console.log('🎰 Slots results:', results);
        
        // Count occurrences of each symbol
        const symbolCounts = {};
        results.forEach(symbol => {
          symbolCounts[symbol] = (symbolCounts[symbol] || 0) + 1;
        });
        
        // Check for 4 of a kind (jackpot)
        const maxCount = Math.max(...Object.values(symbolCounts));
        
        if (maxCount === 4) {
          // JACKPOT! 4 of a kind
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 4);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 5000 XP
          addXP(5000);
          
          showStatus('slots-status', `🎉 JACKPOT! 4x ${winningSymbol} = +5000 XP!`, 'success');
          
          // Show jackpot achievement
          setTimeout(() => {
            showAchievementModal({
              icon: '🎰',
              title: 'JACKPOT WINNER!',
              description: `Amazing! You got 4x ${winningSymbol} and won 5000 XP! You're incredibly lucky!`,
              type: 'slots',
              data: { 
                symbol: winningSymbol, 
                count: 4, 
                xp: 5000,
                result: results.join('')
              }
            });
          }, 1000);
          
        } else if (maxCount === 3) {
          // 3 of a kind - smaller win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 3);
          
          // Highlight winning reels
          document.querySelectorAll('.slot-reel').forEach(reel => {
            if (reel.textContent === winningSymbol) {
              reel.classList.add('winning');
            }
          });
          
          // Award 500 XP for 3 of a kind
          addXP(500);
          
          showStatus('slots-status', `🏆 3x ${winningSymbol} = +500 XP!`, 'success');
          
        } else if (maxCount === 2) {
          // 2 of a kind - small win
          const winningSymbol = Object.keys(symbolCounts).find(symbol => symbolCounts[symbol] === 2);
          
          // Award 50 XP for 2 of a kind
          addXP(50);
          
          showStatus('slots-status', `✨ 2x ${winningSymbol} = +50 XP!`, 'success');
          
        } else {
          // No win
          showStatus('slots-status', '😔 No match this time. Try again!', 'error');
        }
        
        // Clear status and winning highlights after delay
        setTimeout(() => {
          hideStatus('slots-status');
          document.querySelectorAll('.slot-reel').forEach(reel => {
            reel.classList.remove('winning');
          });
        }, 5000);
      }

      // Reset slots display
      function resetSlotsDisplay() {
        const symbols = ['🐕', '🦮', '🐶', '🦴'];
        const reels = ['reel1', 'reel2', 'reel3', 'reel4'];
        
        reels.forEach((reelId, index) => {
          const reel = document.getElementById(reelId);
          reel.textContent = symbols[index];
          reel.classList.remove('spinning', 'winning');
        });
      }

      window.showTab = function(tabName) {
        console.log('📑 Switching to tab:', tabName);
        activeTab = tabName;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
        
        // Update claim UI when switching to claim tab
        if (tabName === 'claim') {
          updateClaimUI();
          // Update balance with delay for better reliability
          setTimeout(() => {
            updateTokenBalance();
          }, 500);
        }
        
        // Update slots when switching to slots tab
        if (tabName === 'slots') {
          resetSlotsDisplay();
          updateSlotsButton();
        }
      };
      
      console.log('🎮 Game functions setup complete');
    }

    async function connectWallet() {
      try {
        console.log('Connecting wallet...');
        
        // Show loading state
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = '🔄 Connecting...';
        connectBtn.disabled = true;
        
        let provider;
        
        if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
          console.log('Using Farcaster wallet');
          provider = sdk.wallet.ethProvider;
        } else if (window.ethereum) {
          console.log('Using browser wallet');
          provider = window.ethereum;
        } else {
          throw new Error('No wallet available');
        }

        // Request accounts with timeout
        const accountsPromise = provider.request({
          method: 'eth_requestAccounts'
        });
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), 10000)
        );
        
        const accounts = await Promise.race([accountsPromise, timeoutPromise]);

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }

        console.log('✅ Connected:', accounts[0]);

        // Setup ethers
        appState.provider = new ethers.providers.Web3Provider(provider);
        appState.signer = appState.provider.getSigner();
        appState.address = accounts[0];
        appState.connected = true;

        // Update UI and load wallet-specific data
        updateWalletUI();
        
        // Load data asynchronously
        updateXPDisplay().catch(console.error);
        
        // Ensure network is correct before fetching balance
        await ensureMonadNetwork();
        
        // Update token balance with multiple retries
        const fetchBalance = async () => {
          for (let i = 0; i < 3; i++) {
            try {
              await updateTokenBalance();
              break;
            } catch (e) {
              console.log(`Balance fetch attempt ${i + 1} failed, retrying...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          }
        };
        
        fetchBalance();

      } catch (error) {
        console.error('Connection error:', error);
        showError(error.message);
        
        // Reset button
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = '🟣 Connect Wallet';
        connectBtn.disabled = false;
      }
    }

    async function disconnect() {
      appState = {
        connected: false,
        address: null,
        xp: 0,
        slotsCredits: 0,
        provider: null,
        signer: null
      };
      updateWalletUI();
      await updateXPDisplay();
      console.log('🔌 Wallet disconnected, XP reset to 0');
    }

    function updateWalletUI() {
      const connectArea = document.getElementById('connect-area');
      const connectedArea = document.getElementById('connected-area');
      const addressEl = document.getElementById('address');

      if (appState.connected) {
        connectArea.style.display = 'none';
        connectedArea.style.display = 'block';
        addressEl.textContent = appState.address.slice(0,6) + '...' + appState.address.slice(-4);
      } else {
        connectArea.style.display = 'block';
        connectedArea.style.display = 'none';
      }
    }

    async function addXP(amount) {
      if (!appState.connected || !appState.address) {
        console.log('❌ Cannot add XP: wallet not connected');
        return;
      }
      
      // Add XP to current balance
      appState.xp = (appState.xp || 0) + amount;
      
      // Update display immediately
      document.getElementById('xp').textContent = appState.xp;
      
      // Save XP to Supabase in background (non-blocking)
      saveWalletXP(appState.address, appState.xp);
      
      // Update claim UI non-blocking
      requestAnimationFrame(() => updateClaimUI());
      
      // Add celebration effect
      const xpElement = document.getElementById('xp');
      xpElement.style.transform = 'scale(1.2)';
      xpElement.style.color = '#00ff00';
      
      setTimeout(() => {
        xpElement.style.transform = 'scale(1)';
        xpElement.style.color = 'white';
      }, 500);
      
      console.log(`✨ XP added to ${appState.address}: +${amount}, Total Available: ${appState.xp}`);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.className = `status visible ${type}`;
    }

    function hideStatus(id) {
      document.getElementById(id).className = 'status';
    }

    function showError(message) {
      const div = document.createElement('div');
      div.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:10px 20px;border-radius:8px;z-index:1000;';
      div.textContent = message;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Real transaction function
    async function executeTransaction(contractAddress, abi, methodName, statusId, successMsg, xpAmount) {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }

      if (appState.isTransactionPending) {
        showError('Please wait for the current transaction to complete');
        return;
      }

      try {
        console.log('🔗 Starting transaction:', methodName);
        
        // Disable all action buttons
        disableAllActionButtons();
        
        showStatus(statusId, 'Preparing transaction...', 'pending');

        // Ensure Monad network
        await ensureMonadNetwork();

        // Create contract instance
        const contract = new ethers.Contract(contractAddress, abi, appState.signer);
        
        showStatus(statusId, '🔐 Please confirm in your wallet...', 'pending');

        // Send transaction
        const tx = await contract[methodName]({
          gasLimit: 100000
        });

        console.log('✅ Transaction sent:', tx.hash);
        showStatus(statusId, `✅ Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');

        // Since Farcaster wallet doesn't support eth_getTransactionReceipt,
        // we'll assume success after a delay
        setTimeout(async () => {
          console.log('✅ Transaction assumed successful');
          showStatus(statusId, successMsg, 'success');
          await addXP(xpAmount);
          
          // Enable all buttons
          enableAllActionButtons();
          
          setTimeout(() => hideStatus(statusId), 3000);
        }, 5000);

      } catch (error) {
        console.error('❌ Transaction error:', error);
        
        // Enable all buttons on error
        enableAllActionButtons();
        
        let errorMsg = 'Transaction failed';
        if (error.message.includes('user rejected') || error.code === 4001) {
          errorMsg = 'Transaction cancelled by user';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient funds for gas';
        }

        showStatus(statusId, errorMsg, 'error');
        setTimeout(() => hideStatus(statusId), 5000);
      }
    }

    async function ensureMonadNetwork() {
      const MONAD_CHAIN_ID = '0x279F'; // 10143 in hex
      
      try {
        const provider = sdk && sdk.wallet && sdk.wallet.ethProvider 
          ? sdk.wallet.ethProvider 
          : window.ethereum;

        if (!provider) {
          throw new Error('No wallet provider available');
        }

        const chainId = await provider.request({ method: 'eth_chainId' });
        console.log('Current chain ID:', chainId);

        if (chainId !== MONAD_CHAIN_ID) {
          console.log('Switching to Monad Testnet...');
          
          try {
            await provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: MONAD_CHAIN_ID }],
            });
            console.log('Switched to Monad Testnet');
          } catch (switchError) {
            if (switchError.code === 4902) {
              console.log('Adding Monad Testnet...');
              await provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: MONAD_CHAIN_ID,
                  chainName: 'Monad Testnet',
                  nativeCurrency: {
                    name: 'Monad',
                    symbol: 'MONAD',
                    decimals: 18
                  },
                  rpcUrls: ['https://testnet-rpc.monad.xyz'],
                  blockExplorerUrls: ['https://testnet.monadscan.com/']
                }]
              });
              console.log('Monad Testnet added');
            }
          }

          // Recreate provider after network switch
          appState.provider = new ethers.providers.Web3Provider(provider);
          appState.signer = appState.provider.getSigner();
        }
      } catch (error) {
        console.error('Network switch error:', error);
        throw new Error('Failed to switch to Monad Testnet');
      }
    }

    // Farcaster Sharing Functions
    function generateShareableContent(type, data = {}) {
      const baseUrl = window.location.origin;
      const tokenBalance = document.getElementById('walletDogDisplay')?.textContent || '0';
      
      const shareTemplates = {
        pet: {
          text: `Just petted the Monad Dog! 🐕✨\n\nXP earned: ${appState.xp}\n$DOG Balance: ${tokenBalance}\n\nJoin me on Monad Testnet!`,
          url: `${baseUrl}?ref=pet&xp=${appState.xp}`,
          image: "🐕"
        },
        greet: {
          text: `GM Monad community! ☀️👋\n\nCommunity XP: ${appState.xp}\n$DOG Tokens: ${tokenBalance}\n\nSpread the love on Monad!`,
          url: `${baseUrl}?ref=greet&xp=${appState.xp}`,
          image: "👋"
        },
        flip: {
          text: `Just flipped a coin on Monad! 🪙\n\nResult: ${data.result || 'Lucky'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}`,
          url: `${baseUrl}?ref=flip&result=${data.result}&xp=${appState.xp}`,
          image: "🪙"
        },
        slots: {
          text: `Just hit the slots on Monad Dog! 🎰\n\nResult: ${data.result || 'Spinning'}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}\n\nTry your luck on Monad!`,
          url: `${baseUrl}?ref=slots&xp=${appState.xp}`,
          image: "🎰"
        },
        claim: {
          text: `Just claimed ${data.amount || 0} $DOG tokens! 💰\n\nTotal $DOG Balance: ${tokenBalance}\nXP reset - earning again!\n\nEarn XP and claim your $DOG tokens too!`,
          url: `${baseUrl}?ref=claim&tokens=${data.amount}`,
          image: "💰"
        },
        invite: {
          text: `Playing Monad Dog - the cutest way to explore Monad Testnet! 🐕⛓️\n\n✨ Pet dogs, flip coins, say GM/GN\n🎯 Earn XP and claim $DOG tokens\n💰 Convert XP to tokens (10:1 rate)\n🚀 Real blockchain interactions\n\nJoin me!`,
          url: `https://monad-snowy.vercel.app?ref=invite&inviter=${appState.address?.slice(0,6)}`,
          image: "🚀"
        }
      };
      
      return shareTemplates[type] || shareTemplates.invite;
    }

    function shareOnFarcaster(content) {
      try {
        if (sdk && sdk.actions && sdk.actions.openUrl) {
          // Use Farcaster SDK for sharing
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          sdk.actions.openUrl(shareUrl);
          console.log('🚀 Shared via Farcaster SDK');
        } else {
          // Fallback to direct URL
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          window.open(shareUrl, '_blank');
          console.log('🚀 Shared via direct URL');
        }
        
        // Track sharing event
        console.log('📊 Share event tracked:', content);
        
      } catch (error) {
        console.error('❌ Share error:', error);
        showError('Failed to open share dialog');
      }
    }

    // Achievement Modal Functions
    window.showAchievementModal = function(achievement) {
      const modal = document.getElementById('achievementModal');
      const icon = document.getElementById('achievementIcon');
      const title = document.getElementById('achievementTitle');
      const description = document.getElementById('achievementDescription');
      
      if (!modal || !icon || !title || !description) {
        console.error('Achievement modal elements not found');
        return;
      }
      
      icon.textContent = achievement.icon || '🎉';
      title.textContent = achievement.title || 'Achievement!';
      description.textContent = achievement.description || '';
      
      modal.style.display = 'flex';
      
      // Store current achievement for sharing
      window.currentAchievement = achievement;
      
      // Add escape key listener
      window.achievementEscapeHandler = function(e) {
        if (e.key === 'Escape') {
          closeAchievementModal();
        }
      };
      document.addEventListener('keydown', window.achievementEscapeHandler);
      
      console.log('🎉 Achievement modal shown:', achievement);
    }

    // Individual Share Functions
    window.sharePetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: '🐕',
        title: 'Dog Lover Achievement!',
        description: `You've been petting dogs and earned ${appState.xp} XP!`,
        type: 'pet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareGreetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: '👋',
        title: 'Community Spirit!',
        description: `You've been greeting the community! Spreading love on Monad with ${appState.xp} XP.`,
        type: 'greet',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareFlipAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const lastResult = document.getElementById('flip-result').textContent;
      const achievement = {
        icon: '🪙',
        title: 'Lucky Flipper!',
        description: `${lastResult} You've been flipping coins on Monad with ${appState.xp} XP!`,
        type: 'flip',
        data: { result: lastResult }
      };
      
      showAchievementModal(achievement);
    };

    window.shareSlotsAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const achievement = {
        icon: '🎰',
        title: 'Slots Player!',
        description: `I've been playing Dog Slots on Monad! Current XP: ${appState.xp}. Try your luck!`,
        type: 'slots',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    window.shareAppWithFriends = function() {
      const achievement = {
        icon: '🚀',
        title: 'Invite Friends!',
        description: 'Share Monad Dog with your friends and build the community together!',
        type: 'invite',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    // Start app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }

    console.log('📱 App script loaded');
    }); // End of DOMContentLoaded
  </script>
</body>
</html>
